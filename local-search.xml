<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hexo 一些小问题</title>
    <link href="/2026/01/04/Hexo-%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2026/01/04/Hexo-%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><h1 id="解决使用Hexo命令无法识别的问题"><a href="#解决使用Hexo命令无法识别的问题" class="headerlink" title="解决使用Hexo命令无法识别的问题"></a>解决使用Hexo命令无法识别的问题</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 1. 删除 node_modules 和 package-lock.json</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-Force</span> node_modules<br><span class="hljs-built_in">Remove-Item</span> package<span class="hljs-literal">-lock</span>.json<br><br><span class="hljs-comment"># 2. 重新安装依赖</span><br><br>npm install<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp required</title>
    <link href="/2025/11/13/C-Sharp-required/"/>
    <url>/2025/11/13/C-Sharp-required/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><p>在 <code>C#</code> 中，<code>required</code> 是一个用于修饰字段、属性或构造函数参数的关键字，主要作用是强制要求在对象初始化时必须显式赋值，确保关键成员不会被遗漏初始化。</p><h1 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h1><h2 id="强制初始化"><a href="#强制初始化" class="headerlink" title="强制初始化"></a>强制初始化</h2><p>当字段或属性被 <code>required</code> 修饰时，创建对象时必须显式为其赋值（无论是通过对象初始化器、构造函数还是其他方式），否则编译会报错。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-comment">// 被 required 修饰的属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">required</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 正确：显式初始化了 required 成员 Name</span><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span>, Age = <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-comment">// 错误：未初始化 required 成员 Name，编译报错</span><br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person &#123; Age = <span class="hljs-number">30</span> &#125;; <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><h2 id="配合构造函数"><a href="#配合构造函数" class="headerlink" title="配合构造函数"></a>配合构造函数</h2><p>若类中定义了构造函数，<code>required</code> 成员也可通过构造函数参数赋值，但需确保构造函数能覆盖所有 <code>required</code> 成员，否则仍需在初始化时补充。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">required</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">required</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 构造函数仅初始化了 Name</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        Name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 正确：通过构造函数初始化 Name，通过对象初始化器补充 Age</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>) &#123; Age = <span class="hljs-number">25</span> &#125;;<br><br><span class="hljs-comment">// 错误：Age 未初始化，编译报错</span><br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>); <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><h2 id="提升代码可读性与安全性"><a href="#提升代码可读性与安全性" class="headerlink" title="提升代码可读性与安全性"></a>提升代码可读性与安全性</h2><p>通过 <code>required</code> 明确标记 “必须初始化的成员”，减少因遗漏赋值导致的运行时错误，使类的使用规则更清晰。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li><code>required</code> 是 <code>C# 11</code> 及以上版本引入的特性，需确保项目使用对应的语言版本。</li><li>接口中的属性也可使用 <code>required</code>，强制实现类必须初始化该属性。</li><li>若需在构造函数中完全初始化 <code>required</code> 成员，可结合 <code>init</code> 访问器（<code>public required string Name { get; init; }</code>），确保初始化后不可修改。</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>required</code> 的核心价值是通过编译时检查，强制关键成员的初始化，提升代码的健壮性和可维护性。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp 主窗口 单例 唯一进程 互斥锁</title>
    <link href="/2025/09/26/C-Sharp-%E4%B8%BB%E7%AA%97%E5%8F%A3-%E5%8D%95%E4%BE%8B-%E5%94%AF%E4%B8%80%E8%BF%9B%E7%A8%8B-%E4%BA%92%E6%96%A5%E9%94%81/"/>
    <url>/2025/09/26/C-Sharp-%E4%B8%BB%E7%AA%97%E5%8F%A3-%E5%8D%95%E4%BE%8B-%E5%94%AF%E4%B8%80%E8%BF%9B%E7%A8%8B-%E4%BA%92%E6%96%A5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><blockquote><p>plana 电脑唯一实例</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Microsoft.VisualBasic.ApplicationServices;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">EngineEMS</span> &#123;<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 应用程序的主入口点</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        [<span class="hljs-meta">STAThread</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span> &#123;<br>            ApplicationConfiguration.Initialize();<br><br>            <span class="hljs-comment">// 使用单实例管理器</span><br>            <span class="hljs-keyword">var</span> singleInstanceManager = <span class="hljs-keyword">new</span> SingleInstanceManager();<br>            singleInstanceManager.Run(Environment.GetCommandLineArgs());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 单实例应用程序管理器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleInstanceManager</span> : <span class="hljs-title">WindowsFormsApplicationBase</span> &#123;<br>        <span class="hljs-keyword">private</span> MainForm _mainForm;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SingleInstanceManager</span>()</span> &#123;<br>            <span class="hljs-comment">// 启用单实例应用</span><br>            IsSingleInstance = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 当创建新实例时执行</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreateMainForm</span>()</span> &#123;<br>            _mainForm = <span class="hljs-keyword">new</span> MainForm();<br>            MainForm = _mainForm;<br>        &#125;<br><br>        <span class="hljs-comment">// 当检测到已有实例时执行</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStartupNextInstance</span>(<span class="hljs-params">StartupNextInstanceEventArgs eventArgs</span>)</span> &#123;<br>            <span class="hljs-keyword">base</span>.OnStartupNextInstance(eventArgs);<br><br>            <span class="hljs-comment">// 激活已存在的主窗口</span><br>            <span class="hljs-keyword">if</span> (MainForm != <span class="hljs-literal">null</span>) &#123;<br>                MainForm.WindowState = FormWindowState.Maximized; <span class="hljs-comment">// 确保窗口最大化</span><br>                MainForm.Activate();    <span class="hljs-comment">// 激活窗口</span><br>                MainForm.BringToFront();<span class="hljs-comment">// 前置窗口</span><br>                MainForm.Focus();       <span class="hljs-comment">// 设置焦点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>planb 不用</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO.Pipes;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">EngineEMS</span> &#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br>        <span class="hljs-comment">// 应用程序唯一标识（建议生成新的GUID）</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> UniqueAppId = <span class="hljs-string">$&quot;&#123;&#123;AFC5ASE5-LGHJ-4D5C-9A5A-CNNO20010810&#125;&#125;&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> PipeName = <span class="hljs-string">$&quot;EngineEMS_<span class="hljs-subst">&#123;UniqueAppId&#125;</span>&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MainForm _mainForm;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 应用程序的主入口点</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        [<span class="hljs-meta">STAThread</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span> &#123;<br>            <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> mutex = <span class="hljs-keyword">new</span> Mutex(<span class="hljs-literal">true</span>, UniqueAppId, <span class="hljs-keyword">out</span> <span class="hljs-built_in">bool</span> isNewInstance);<br><br>            <span class="hljs-keyword">if</span> (!isNewInstance) &#123;<br>                <span class="hljs-comment">// 不是第一个实例，通过管道通知第一个实例激活窗口</span><br>                NotifyFirstInstance();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 第一个实例，启动管道服务器监听新实例</span><br>                StartPipeServer();<br><br>                <span class="hljs-comment">// 正常启动应用程序</span><br>                ApplicationConfiguration.Initialize();<br>                _mainForm = <span class="hljs-keyword">new</span> MainForm();<br>                Application.Run(_mainForm);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放互斥体</span><br>                mutex.ReleaseMutex();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 启动命名管道服务器，监听新实例的激活请求</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartPipeServer</span>()</span> &#123;<br>            <span class="hljs-keyword">var</span> thread = <span class="hljs-keyword">new</span> Thread(PipeServerLoop) &#123;<br>                IsBackground = <span class="hljs-literal">true</span>,<br>                Name = <span class="hljs-string">&quot;PipeServerThread&quot;</span><br>            &#125;;<br>            thread.Start();<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 管道服务器循环，持续监听新实例</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PipeServerLoop</span>()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> pipeServer = <span class="hljs-keyword">new</span> NamedPipeServerStream(<br>                        PipeName,<br>                        PipeDirection.In,<br>                        <span class="hljs-number">1</span>,<br>                        PipeTransmissionMode.Byte,<br>                        PipeOptions.Asynchronous);<br><br>                    <span class="hljs-comment">// 等待客户端连接</span><br>                    pipeServer.WaitForConnection();<br><br>                    <span class="hljs-comment">// 收到连接，激活主窗口</span><br>                    _mainForm?.Invoke((Action)ActivateMainWindow);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                    <span class="hljs-comment">// 记录错误但不中断循环</span><br>                    Console.WriteLine(<span class="hljs-string">$&quot;管道服务器错误: <span class="hljs-subst">&#123;ex.Message&#125;</span>&quot;</span>);<br>                    Thread.Sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 避免错误时CPU占用过高</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 激活主窗口</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ActivateMainWindow</span>()</span> &#123;<br>            <span class="hljs-keyword">if</span> (_mainForm == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-comment">// 恢复窗口（如果最小化）</span><br>            <span class="hljs-keyword">if</span> (_mainForm.WindowState == FormWindowState.Minimized) &#123;<br>                _mainForm.WindowState = FormWindowState.Maximized;<br>            &#125;<br><br>            <span class="hljs-comment">// 激活并前置窗口</span><br>            _mainForm.ShowInTaskbar = <span class="hljs-literal">true</span>;<br>            _mainForm.Activate();<br>            _mainForm.BringToFront();<br>            _mainForm.Focus();<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 通知第一个实例激活窗口</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyFirstInstance</span>()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> pipeClient = <span class="hljs-keyword">new</span> NamedPipeClientStream(<span class="hljs-string">&quot;.&quot;</span>, PipeName, PipeDirection.Out);<br>                pipeClient.Connect(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 1秒超时</span><br>                <span class="hljs-comment">// 连接成功即表示通知已发送，无需实际写入数据</span><br>            &#125; <span class="hljs-keyword">catch</span> (TimeoutException) &#123;<br>                MessageBox.Show(<span class="hljs-string">&quot;程序已在运行中，但无法连接到现有实例。&quot;</span>,<br>                              <span class="hljs-string">&quot;程序已运行&quot;</span>,<br>                              MessageBoxButtons.OK,<br>                              MessageBoxIcon.Information);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                MessageBox.Show(<span class="hljs-string">$&quot;程序已在运行中，但发送激活请求时出错：<span class="hljs-subst">&#123;ex.Message&#125;</span>&quot;</span>,<br>                              <span class="hljs-string">&quot;错误&quot;</span>,<br>                              MessageBoxButtons.OK,<br>                              MessageBoxIcon.Error);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>planc 不用</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><span class="hljs-keyword">using</span> Microsoft.VisualBasic.ApplicationServices;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">EngineEMS</span> &#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 应用程序的主入口点</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        [<span class="hljs-meta">STAThread</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span> &#123;<br>            ApplicationConfiguration.Initialize();<br><br>            <span class="hljs-comment">// 使用单实例管理器</span><br>            <span class="hljs-keyword">var</span> singleInstanceManager = <span class="hljs-keyword">new</span> SingleInstanceManager();<br>            singleInstanceManager.Run(Environment.GetCommandLineArgs());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 单实例应用程序管理器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleInstanceManager</span> : <span class="hljs-title">WindowsFormsApplicationBase</span> &#123;<br>        <span class="hljs-keyword">private</span> MainForm _mainForm;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SingleInstanceManager</span>()</span> &#123;<br>            <span class="hljs-comment">// 启用单实例应用</span><br>            IsSingleInstance = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 当创建新实例时执行</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreateMainForm</span>()</span> &#123;<br>            _mainForm = <span class="hljs-keyword">new</span> MainForm();<br>            MainForm = _mainForm;<br>        &#125;<br><br>        <span class="hljs-comment">// 当检测到已有实例时执行</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStartupNextInstance</span>(<span class="hljs-params">StartupNextInstanceEventArgs eventArgs</span>)</span> &#123;<br>            <span class="hljs-keyword">base</span>.OnStartupNextInstance(eventArgs);<br><br>            <span class="hljs-comment">// 激活已存在的主窗口</span><br>            <span class="hljs-keyword">if</span> (MainForm != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 恢复窗口（如果最小化）</span><br>                <span class="hljs-keyword">if</span> (MainForm.WindowState == FormWindowState.Minimized) &#123;<br>                    MainForm.WindowState = FormWindowState.Normal;<br>                &#125;<br><br>                <span class="hljs-comment">// 激活并前置窗口</span><br>                MainForm.Activate();<br>                MainForm.BringToFront();<br>                MainForm.Focus();<br>            &#125;<br><br>            <span class="hljs-comment">// 处理新实例传递的命令行参数</span><br>            <span class="hljs-keyword">if</span> (eventArgs.CommandLine.Count &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 可以在这里将命令行参数传递给主窗口处理</span><br>                <span class="hljs-comment">// _mainForm.ProcessCommandLineArgs(eventArgs.CommandLine);</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><em><strong>251012</strong></em></p><h1 id="建议使用pland"><a href="#建议使用pland" class="headerlink" title="建议使用pland"></a>建议使用pland</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">发现单实例是电脑只能运行一个实例，即使多拷贝文件夹项目也不行<br>故<br></code></pre></td></tr></table></figure><blockquote><p>pland api </p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Diagnostics;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><span class="hljs-keyword">using</span> System.Security.Cryptography;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">AFCTest</span> &#123;<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br><br>        [<span class="hljs-meta">STAThread</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span> &#123;<br>            ApplicationConfiguration.Initialize();<br>            Application.EnableVisualStyles();<br>            Application.SetCompatibleTextRenderingDefault(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">// 获取当前程序目录</span><br>            <span class="hljs-built_in">string</span> exeDirectory = Path.GetDirectoryName(Application.ExecutablePath);<br>            <span class="hljs-built_in">string</span> mutexName = GenerateMutexName(exeDirectory);<br><br>            <span class="hljs-comment">// 检测实例</span><br>            <span class="hljs-keyword">using</span> Mutex mutex = <span class="hljs-keyword">new</span>(<span class="hljs-literal">true</span>, mutexName, <span class="hljs-keyword">out</span> <span class="hljs-built_in">bool</span> isNewInstance);<br>            <span class="hljs-keyword">if</span> (isNewInstance) &#123;<br>                <span class="hljs-comment">// 新实例：运行主窗口</span><br>                Application.Run(<span class="hljs-keyword">new</span> MainForm());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 已有实例：尝试激活</span><br>                ActivateExistingInstance(exeDirectory);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 生成基于目录的唯一互斥体名称</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GenerateMutexName</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> directory</span>)</span> &#123;<br>            <span class="hljs-built_in">byte</span>[] hashBytes = SHA256.HashData(Encoding.UTF8.GetBytes(directory));<br>            <span class="hljs-built_in">string</span> hashString = BitConverter.ToString(hashBytes).Replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).ToLower();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;Local\\AFCTest_<span class="hljs-subst">&#123;hashString&#125;</span>&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 激活已存在的实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ActivateExistingInstance</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> targetDirectory</span>)</span> &#123;<br>            <span class="hljs-built_in">string</span> processName = Process.GetCurrentProcess().ProcessName;<br><br>            <span class="hljs-keyword">foreach</span> (Process process <span class="hljs-keyword">in</span> Process.GetProcessesByName(processName)) &#123;<br>                <span class="hljs-keyword">if</span> (process.Id == Environment.ProcessId)<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-comment">// 检查进程路径是否匹配</span><br>                <span class="hljs-built_in">string</span> processPath = process.MainModule?.FileName;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.IsNullOrEmpty(processPath))<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.Equals(Path.GetDirectoryName(processPath), targetDirectory,<br>                                 StringComparison.OrdinalIgnoreCase)) &#123;<br>                    <span class="hljs-comment">// 激活窗口</span><br>                    <span class="hljs-keyword">if</span> (process.MainWindowHandle != IntPtr.Zero) &#123;<br>                        ShowWindow(process.MainWindowHandle, SW_RESTORE);<br>                        <span class="hljs-keyword">return</span> SetForegroundWindow(process.MainWindowHandle);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> Windows API</span><br><br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ShowWindow</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">int</span> nCmdShow</span>)</span>;<br><br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">SetForegroundWindow</span>(<span class="hljs-params">IntPtr hWnd</span>)</span>;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SW_RESTORE = <span class="hljs-number">9</span>;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span> Windows API</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>plane 管道</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.IO.Pipes;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><span class="hljs-keyword">using</span> System.Diagnostics;<br><span class="hljs-keyword">using</span> System.Security.Cryptography;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">AFCTest</span> &#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br>        <span class="hljs-comment">// 管道名称前缀</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> PipePrefix = <span class="hljs-string">&quot;AFCTest_Pipe_&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> _pipeName;<br><br>        [<span class="hljs-meta">STAThread</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span> &#123;<br>            ApplicationConfiguration.Initialize();<br>            Application.EnableVisualStyles();<br>            Application.SetCompatibleTextRenderingDefault(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">// 获取当前程序目录</span><br>            <span class="hljs-built_in">string</span> exeDirectory = Path.GetDirectoryName(Application.ExecutablePath);<br>            <span class="hljs-built_in">string</span> mutexName = GenerateMutexName(exeDirectory);<br>            _pipeName = <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;PipePrefix&#125;</span><span class="hljs-subst">&#123;GenerateHashString(exeDirectory)&#125;</span>&quot;</span>;<br><br>            <span class="hljs-comment">// 检测实例</span><br>            <span class="hljs-keyword">using</span> Mutex mutex = <span class="hljs-keyword">new</span>(<span class="hljs-literal">true</span>, mutexName, <span class="hljs-keyword">out</span> <span class="hljs-built_in">bool</span> isNewInstance);<br>            <span class="hljs-keyword">if</span> (isNewInstance) &#123;<br>                <span class="hljs-comment">// 新实例：启动管道服务器并运行主窗口</span><br>                StartPipeServer();<br>                Application.Run(<span class="hljs-keyword">new</span> MainForm());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 已有实例：通过管道发送激活请求</span><br>                <span class="hljs-keyword">if</span> (!SendActivateRequest()) &#123;<br>                    MessageBox.Show(<span class="hljs-string">&quot;同一目录下已有程序实例在运行中&quot;</span>, <span class="hljs-string">&quot;提示&quot;</span>,<br>                                  MessageBoxButtons.OK, MessageBoxIcon.Information);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 生成基于目录的唯一互斥体名称</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GenerateMutexName</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> directory</span>)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;Local\\AFCTest_<span class="hljs-subst">&#123;GenerateHashString(directory)&#125;</span>&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 生成目录的哈希字符串</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GenerateHashString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> input</span>)</span> &#123;<br>            <span class="hljs-built_in">byte</span>[] hashBytes = SHA256.HashData(Encoding.UTF8.GetBytes(input));<br>            <span class="hljs-keyword">return</span> BitConverter.ToString(hashBytes).Replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).ToLower();<br>        &#125;<br><br>        <span class="hljs-comment">// 启动管道服务器，监听激活请求</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartPipeServer</span>()</span> &#123;<br>            Task.Run(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">using</span> (NamedPipeServerStream server = <span class="hljs-keyword">new</span> NamedPipeServerStream(<br>                            _pipeName, PipeDirection.In, <span class="hljs-number">1</span>, PipeTransmissionMode.Byte)) &#123;<br><br>                            <span class="hljs-keyword">await</span> server.WaitForConnectionAsync();<br><br>                            <span class="hljs-comment">// 收到激活请求，在UI线程激活窗口</span><br>                            Application.OpenForms[<span class="hljs-number">0</span>]?.BeginInvoke((Action)(() =&gt; &#123;<br>                                <span class="hljs-keyword">var</span> mainForm = Application.OpenForms[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> MainForm;<br>                                <span class="hljs-keyword">if</span> (mainForm != <span class="hljs-literal">null</span>) &#123;<br>                                    mainForm.WindowState = FormWindowState.Normal;<br>                                    mainForm.BringToFront();<br>                                    mainForm.Focus();<br>                                &#125;<br>                            &#125;));<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span>  &#123;<br>                        <span class="hljs-comment">// 处理管道错误，如管道已关闭等</span><br>                        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 向已有实例发送激活请求</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">SendActivateRequest</span>()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">using</span> (NamedPipeClientStream client = <span class="hljs-keyword">new</span> NamedPipeClientStream(<span class="hljs-string">&quot;.&quot;</span>, _pipeName, PipeDirection.Out)) &#123;<br>                    <span class="hljs-comment">// 尝试连接到管道，超时时间1秒</span><br>                    client.Connect(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> &#123;<br>                <span class="hljs-comment">// 连接失败，没有找到已有实例</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp Progress</title>
    <link href="/2025/09/18/C-Sharp-Progress/"/>
    <url>/2025/09/18/C-Sharp-Progress/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><p>在 <code>C#</code> 中，<code>Progress&lt;T&gt;</code> 是一个用于报告操作进度的类，它实现了 <code>IProgress&lt;T&gt;</code> 接口，通常用于异步操作中向 <code>UI</code> 线程或其他上下文报告进度更新。</p><h1 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h1><ul><li><strong>创建 <code>Progress</code> 实例</strong>：实例化 <code>Progress&lt;T&gt;</code> 时，需要提供一个回调方法，该方法会在进度更新时被调用。</li><li><strong>报告进度</strong>：在异步操作中，通过调用 <code>IProgress&lt;T&gt;.Report(T value)</code> 方法来报告当前进度。</li><li><strong>处理进度更新</strong>：回调方法会在创建 <code>Progress&lt;T&gt;</code> 实例的上下文（通常是 <code>UI</code> 线程）中执行，因此可以安全地更新 <code>UI</code>。</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个简单的示例，展示如何使用 Progress<T> 报告任务进度：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><br><span class="hljs-comment">// 假设这是一个Windows Forms应用程序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> : <span class="hljs-title">Form</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainForm</span>()</span><br>    &#123;<br>        InitializeComponent();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartButton_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 创建Progress实例，指定进度更新时的回调方法</span><br>        IProgress&lt;<span class="hljs-built_in">int</span>&gt; progress = <span class="hljs-keyword">new</span> Progress&lt;<span class="hljs-built_in">int</span>&gt;(UpdateProgress);<br>        <br>        <span class="hljs-comment">// 启动异步任务，并传递progress对象</span><br>        <span class="hljs-keyword">await</span> DoWorkAsync(progress);<br>        <br>        MessageBox.Show(<span class="hljs-string">&quot;任务完成！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 进度更新的回调方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateProgress</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> percentage</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 这里可以安全地更新UI，因为Progress会在UI线程执行此方法</span><br>        progressBar1.Value = percentage;<br>        statusLabel.Text = <span class="hljs-string">$&quot;进度：<span class="hljs-subst">&#123;percentage&#125;</span>%&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 模拟一个耗时的异步操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DoWorkAsync</span>(<span class="hljs-params">IProgress&lt;<span class="hljs-built_in">int</span>&gt; progress</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>        &#123;<br>            <span class="hljs-comment">// 模拟工作</span><br>            <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">50</span>);<br>            <br>            <span class="hljs-comment">// 报告当前进度</span><br>            progress?.Report(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h2><ul><li><strong>线程安全</strong>：<code>Progress&lt;T&gt;</code> 会捕获创建时的同步上下文（<code>SynchronizationContext</code>），并在该上下文中执行回调方法。这意味着在 <code>UI</code> 应用程序中，回调方法会自动在 <code>UI</code> 线程上执行，避免了跨线程访问 <code>UI</code> 控件的问题。</li><li><strong>泛型类型 <code>T</code></strong>：<code>T</code> 可以是任何类型，不仅限于整数。例如，你可以定义一个自定义类来传递更详细的进度信息：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProgressInfo</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Percentage &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用自定义类型</span><br>IProgress&lt;ProgressInfo&gt; progress = <span class="hljs-keyword">new</span> Progress&lt;ProgressInfo&gt;(info =&gt;<br>&#123;<br>    progressBar1.Value = info.Percentage;<br>    statusLabel.Text = info.Message;<br>&#125;);<br><br><span class="hljs-comment">// 报告进度</span><br>progress.Report(<span class="hljs-keyword">new</span> ProgressInfo &#123; Percentage = <span class="hljs-number">50</span>, Message = <span class="hljs-string">&quot;正在处理...&quot;</span> &#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>null 检查</strong>：在调用 <code>Report</code> 方法时，建议先检查 <code>progress</code> 是否为 <code>null</code>，以避免在未提供进度报告器时出现异常。</li><li><strong>与异步方法配合</strong>：<code>Progress&lt;T&gt;</code> 通常与 <code>async/await</code> 一起使用，用于在长时间运行的异步操作中提供反馈。</li></ul><hr><p>通过使用 <code>Progress&lt;T&gt;</code>，你可以很方便地在 <code>C#</code> 应用程序中实现进度报告功能，提升用户体验。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp 集合表达式和展开运算符 (..) 详解</title>
    <link href="/2025/07/07/C-Sharp-%E9%9B%86%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/07/07/C-Sharp-%E9%9B%86%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><h1 id="集合表达式-Collection-Expressions"><a href="#集合表达式-Collection-Expressions" class="headerlink" title="集合表达式 (Collection Expressions)"></a>集合表达式 (<code>Collection Expressions</code>)</h1><p><code>C# 12</code> 引入了集合表达式，提供了一种更简洁的方式来创建和初始化集合。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 创建数组</span><br><span class="hljs-built_in">int</span>[] array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// 创建列表</span><br>List&lt;<span class="hljs-built_in">int</span>&gt; list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// 创建跨度(Span)</span><br>Span&lt;<span class="hljs-built_in">int</span>&gt; span = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h2 id="支持的集合类型"><a href="#支持的集合类型" class="headerlink" title="支持的集合类型"></a>支持的集合类型</h2><p>集合表达式支持多种集合类型：</p><ul><li>数组 (<code>T[]</code>)</li><li><code>List&lt;T&gt;</code></li><li><code>Span&lt;T&gt;</code> 和 <code>ReadOnlySpan&lt;T&gt;</code></li><li>实现了 <code>IEnumerable&lt;T&gt;</code> 并有合适 <code>Add</code> 方法的类型</li></ul><h1 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符 (..)"></a>展开运算符 (<code>..</code>)</h1><p>展开运算符用于将现有集合的元素”展开”到新的集合中。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-built_in">int</span>[] numbers1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">int</span>[] numbers2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><br><span class="hljs-comment">// 合并两个数组</span><br><span class="hljs-built_in">int</span>[] combined = [.. numbers1, .. numbers2]; <br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br><br><span class="hljs-comment">// 添加额外元素</span><br><span class="hljs-built_in">int</span>[] withExtra = [.. numbers1, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, .. numbers2]; <br><span class="hljs-comment">// [1, 2, 3, 10, 20, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><h1 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h1><h2 id="创建新集合"><a href="#创建新集合" class="headerlink" title="创建新集合"></a>创建新集合</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 传统方式</span><br>List&lt;<span class="hljs-built_in">string</span>&gt; oldWay = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> &#125;;<br><br><span class="hljs-comment">// 新方式</span><br>List&lt;<span class="hljs-built_in">string</span>&gt; newWay = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>];<br></code></pre></td></tr></table></figure><h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cs">List&lt;<span class="hljs-built_in">int</span>&gt; first = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>List&lt;<span class="hljs-built_in">int</span>&gt; second = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><br><span class="hljs-comment">// 合并两个列表</span><br>List&lt;<span class="hljs-built_in">int</span>&gt; merged = [.. first, .. second];<br></code></pre></td></tr></table></figure><h2 id="与现有API结合"><a href="#与现有API结合" class="headerlink" title="与现有API结合"></a>与现有API结合</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 传递给需要IEnumerable的方法</span><br>ProcessNumbers([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessNumbers</span>(<span class="hljs-params">IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; numbers</span>)</span><br>&#123;<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> numbers)<br>    &#123;<br>        Console.WriteLine(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h1><p>集合表达式通常能提供更好的性能</p><ul><li>对于数组，编译器会优化为直接的数组初始化</li><li>对于列表，编译器会使用最有效的方式初始化</li></ul><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><h2 id="多维集合"><a href="#多维集合" class="headerlink" title="多维集合"></a>多维集合</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-built_in">int</span>[][] matrix = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]];<br></code></pre></td></tr></table></figure><h2 id="自定义集合"><a href="#自定义集合" class="headerlink" title="自定义集合"></a>自定义集合</h2><p>要使自定义集合支持集合表达式，需要实现：</p><ul><li><code>IEnumerable&lt;T&gt;</code></li><li>有一个可访问的 <code>Add</code> 方法</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomCollection</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> List&lt;T&gt; _items = <span class="hljs-keyword">new</span>();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span> =&gt; _items.Add(item);<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;T&gt; <span class="hljs-title">GetEnumerator</span>()</span> =&gt; _items.GetEnumerator();<br>    <br>    IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>CustomCollection&lt;<span class="hljs-built_in">int</span>&gt; custom = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>展开运算符 (<code>..</code>) 只能用于集合表达式内部</li><li>集合表达式不能用于 <code>null</code> 值</li><li>目标类型必须明确（不能用于 <code>var</code> 推断）</li></ul><h1 id="与传统方式的比较"><a href="#与传统方式的比较" class="headerlink" title="与传统方式的比较"></a>与传统方式的比较</h1><table><thead><tr><th>特性</th><th>集合表达式</th><th>传统方式</th></tr></thead><tbody><tr><td><strong>语法简洁性</strong></td><td>✅ 高（单行简洁语法）</td><td>❌ 低（需要更多样板代码）</td></tr><tr><td><strong>可读性</strong></td><td>⭐⭐⭐ 高（直观表达意图）</td><td>⭐⭐ 中等（结构略显冗长）</td></tr><tr><td><strong>灵活性</strong></td><td>🔄 高（支持混合元素和展开）</td><td>🔄 高（但语法更复杂）</td></tr><tr><td><strong>性能</strong></td><td>⚡ 优化更好（编译器特殊处理）</td><td>⏳ 一般（标准初始化流程）</td></tr><tr><td><strong>版本要求</strong></td><td>🆕 C# 12+</td><td>🏛️ 所有版本</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>C#</code> 的集合表达式和展开运算符提供了：</p><ul><li>更简洁的集合初始化语法</li><li>更直观的集合合并方式</li><li>更好的代码可读性</li><li>编译器优化的性能优势</li></ul><p>建议在新项目中使用这些特性，特别是在需要频繁创建或合并集合的场景中。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp Serilog 日志</title>
    <link href="/2025/06/10/C-Sharp-Serilog-%E6%97%A5%E5%BF%97/"/>
    <url>/2025/06/10/C-Sharp-Serilog-%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><p><code>Serilog</code> 是一个流行的 <code>.NET</code> 日志库，用于记录应用程序的运行日志。它提供了灵活的配置方式和丰富的日志输出选项，支持将日志输出到控制台、文件、数据库、云存储等多种目标。以下是关于 <code>Serilog</code> 在 <code>C#</code> 中的使用方法和一些常见配置的介绍。</p><h1 id="Serilog-的基本概念"><a href="#Serilog-的基本概念" class="headerlink" title="Serilog 的基本概念"></a>Serilog 的基本概念</h1><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p><code>Serilog</code> 支持多种日志级别，从低到高依次是：</p><ul><li><code>Verbose</code>（详细）：记录最详细的信息，通常用于调试。</li><li><code>Debug</code>（调试）：记录调试信息，比 <code>Verbose</code> 稍低。</li><li><code>Information</code>（信息）：记录正常运行时的信息。</li><li><code>Warning</code>（警告）：记录可能影响正常运行的警告信息。</li><li><code>Error</code>（错误）：记录运行时的错误。</li><li><code>Fatal</code>（致命）：记录导致应用程序崩溃的致命错误。</li></ul><h2 id="日志输出目标（Sink）"><a href="#日志输出目标（Sink）" class="headerlink" title="日志输出目标（Sink）"></a>日志输出目标（<code>Sink</code>）</h2><p><code>Serilog</code> 支持多种日志输出目标，例如：</p><ul><li>控制台（<code>Console</code>）</li><li>文件（<code>File</code>）</li><li>数据库（如 <code>SQL Server</code>、<code>MySQL</code>）</li><li>云存储（如 <code>Azure Blob Storage</code>、<code>AWS S3</code>）</li><li>日志聚合工具（如 <code>Elasticsearch</code>、<code>Seq</code>）</li></ul><h1 id="安装-Serilog"><a href="#安装-Serilog" class="headerlink" title="安装 Serilog"></a>安装 <code>Serilog</code></h1><p>在 <code>C#</code> 项目中使用 <code>Serilog</code>，首先需要安装相关的 <code>NuGet</code> 包。以下是一些常用的 <code>Serilog</code> 包：</p><ul><li><code>Serilog</code>：核心日志库。</li><li><code>Serilog.Sinks.Console</code>：将日志输出到控制台。</li><li><code>Serilog.Sinks.File</code>：将日志输出到文件。</li><li><code>Serilog.Sinks.MSSqlServer</code>：将日志输出到 <code>SQL Server</code> 数据库。</li><li><code>Serilog.Settings.Configuration</code>：通过配置文件（如 <code>appsettings.json</code>）配置 <code>Serilog</code>。<br>可以通过 <code>NuGet</code> 包管理器安装这些包。</li></ul><h1 id="配置-Serilog"><a href="#配置-Serilog" class="headerlink" title="配置 Serilog"></a>配置 <code>Serilog</code></h1><h2 id="程序代码中配置"><a href="#程序代码中配置" class="headerlink" title="程序代码中配置"></a>程序代码中配置</h2><p>在代码中直接配置 <code>Serilog</code> 是最直接的方式。以下是一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Serilog;<br><span class="hljs-keyword">using</span> Serilog.Sinks.File;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 配置日志</span><br>        Log.Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()<br>            .MinimumLevel.Debug() <span class="hljs-comment">// 设置最低日志级别</span><br>            .WriteTo.Console()    <span class="hljs-comment">// 输出到控制台</span><br>            .WriteTo.File(<span class="hljs-string">&quot;logs/log.txt&quot;</span>, rollingInterval: RollingInterval.Day) <span class="hljs-comment">// 输出到文件，按天滚动</span><br>            .CreateLogger();<br><br>        <span class="hljs-comment">// 写入日志</span><br>        Log.Information(<span class="hljs-string">&quot;This is an information message.&quot;</span>);<br>        Log.Warning(<span class="hljs-string">&quot;This is a warning message.&quot;</span>);<br>        Log.Error(<span class="hljs-string">&quot;This is an error message.&quot;</span>);<br><br>        <span class="hljs-comment">// 关闭日志</span><br>        Log.CloseAndFlush();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通过配置文件配置"><a href="#通过配置文件配置" class="headerlink" title="通过配置文件配置"></a>通过配置文件配置</h2><p><code>Serilog</code> 也支持通过配置文件（如 <code>appsettings.json</code>）进行配置，这种方式更加灵活。首先需要安装 <code>Serilog.Settings.Configuration</code> 包：<br>然后在 <code>appsettings.json</code> 文件中配置 <code>Serilog</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp">&#123;<br>  <span class="hljs-string">&quot;Serilog&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;MinimumLevel&quot;</span>: <span class="hljs-string">&quot;Debug&quot;</span>,<br>    <span class="hljs-string">&quot;WriteTo&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Console&quot;</span><br>      &#125;,<br>      &#123;<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;File&quot;</span>,<br>        <span class="hljs-string">&quot;Args&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;logs/log.txt&quot;</span>,<br>          <span class="hljs-string">&quot;rollingInterval&quot;</span>: <span class="hljs-string">&quot;Day&quot;</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在程序中加载配置文件并初始化 <code>Serilog</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Microsoft.Extensions.Configuration;<br><span class="hljs-keyword">using</span> Serilog;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 加载配置文件</span><br>        <span class="hljs-keyword">var</span> configuration = <span class="hljs-keyword">new</span> ConfigurationBuilder()<br>            .AddJsonFile(<span class="hljs-string">&quot;appsettings.json&quot;</span>)<br>            .Build();<br><br>        <span class="hljs-comment">// 配置 Serilog</span><br>        Log.Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()<br>            .ReadFrom.Configuration(configuration)<br>            .CreateLogger();<br><br>        <span class="hljs-comment">// 写入日志</span><br>        Log.Information(<span class="hljs-string">&quot;This is an information message.&quot;</span>);<br>        Log.Warning(<span class="hljs-string">&quot;This is a warning message.&quot;</span>);<br>        Log.Error(<span class="hljs-string">&quot;This is an error message.&quot;</span>);<br><br>        <span class="hljs-comment">// 关闭日志</span><br>        Log.CloseAndFlush();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常见配置选项"><a href="#常见配置选项" class="headerlink" title="常见配置选项"></a>常见配置选项</h1><h2 id="日志级别-1"><a href="#日志级别-1" class="headerlink" title="日志级别"></a>日志级别</h2><p>可以通过 <code>MinimumLevel</code> 设置最低日志级别，低于该级别的日志将不会被记录。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Log.Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()<br>    .MinimumLevel.Warning() <span class="hljs-comment">// 只记录 Warning 及以上级别的日志</span><br>    .CreateLogger();<br></code></pre></td></tr></table></figure><h2 id="文件日志"><a href="#文件日志" class="headerlink" title="文件日志"></a>文件日志</h2><p>文件日志是常用的日志输出方式。<code>Serilog</code> 提供了丰富的文件日志配置选项，例如：</p><ul><li>文件路径：指定日志文件的存储路径。</li><li>滚动策略：按时间（如按天、按小时）或大小滚动日志文件。</li><li>保留策略：设置保留的日志文件数量或天数。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Log.Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()<br>    .WriteTo.File(<span class="hljs-string">&quot;logs/log.txt&quot;</span>, rollingInterval: RollingInterval.Day, retainedFileCountLimit: <span class="hljs-number">7</span>)<br>    .CreateLogger();<br></code></pre></td></tr></table></figure><h2 id="控制台日志"><a href="#控制台日志" class="headerlink" title="控制台日志"></a>控制台日志</h2><p>控制台日志可以实时显示日志信息，方便调试。可以通过以下方式配置控制台日志：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Log.Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()<br>    .WriteTo.Console(outputTemplate: <span class="hljs-string">&quot;[&#123;Timestamp:HH:mm:ss&#125; &#123;Level&#125;] &#123;Message&#125;&#123;NewLine&#125;&#123;Exception&#125;&quot;</span>)<br>    .CreateLogger();<br></code></pre></td></tr></table></figure><p>其中，<code>outputTemplate</code> 可以自定义日志的输出格式。</p><h2 id="数据库日志"><a href="#数据库日志" class="headerlink" title="数据库日志"></a>数据库日志</h2><p><code>Serilog</code> 支持将日志输出到多种数据库，例如 <code>SQL Server</code>、<code>MySQL</code> 等。以下是将日志输出到 <code>SQL Server</code> 数据库的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Log.Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()<br>    .WriteTo.MSSqlServer(<br>        connectionString: <span class="hljs-string">&quot;Server=your_server;Database=your_database;User Id=your_user;Password=your_password;&quot;</span>,<br>        tableName: <span class="hljs-string">&quot;Logs&quot;</span>,<br>        autoCreateSqlTable: <span class="hljs-literal">true</span>)<br>    .CreateLogger();<br></code></pre></td></tr></table></figure><p>在数据库中，<code>Serilog</code> 会自动创建一个日志表（如 <code>Logs</code>），并存储日志信息。</p><h1 id="使用-Serilog-在-ASP-NET-Core-中"><a href="#使用-Serilog-在-ASP-NET-Core-中" class="headerlink" title="使用 Serilog 在 ASP.NET Core 中"></a>使用 <code>Serilog</code> 在 <code>ASP.NET Core</code> 中</h1><p><code>Serilog</code> 也可以与 <code>ASP.NET Core</code> 集成，为 <code>Web</code> 应用程序提供日志功能。以下是一个集成的示例：</p><h2 id="安装-NuGet-包"><a href="#安装-NuGet-包" class="headerlink" title="安装 NuGet 包"></a>安装 <code>NuGet</code> 包</h2><p>安装以下 <code>NuGet</code> 包：</p><ul><li><code>Serilog.AspNetCore</code></li><li><code>Serilog.Sinks.Console</code></li><li><code>Serilog.Sinks.File</code></li></ul><h2 id="配置-Serilog-1"><a href="#配置-Serilog-1" class="headerlink" title="配置 Serilog"></a>配置 <code>Serilog</code></h2><p>在 <code>Program.cs</code> 文件中配置 <code>Serilog</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Serilog;<br><br><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(<span class="hljs-keyword">args</span>);<br><br><span class="hljs-comment">// 配置 Serilog</span><br>Log.Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()<br>    .MinimumLevel.Debug()<br>    .WriteTo.Console()<br>    .WriteTo.File(<span class="hljs-string">&quot;logs/log.txt&quot;</span>, rollingInterval: RollingInterval.Day)<br>    .CreateLogger();<br><br>builder.Host.UseSerilog();<br><br><span class="hljs-keyword">var</span> app = builder.Build();<br><br>app.MapGet(<span class="hljs-string">&quot;/&quot;</span>, () =&gt; <span class="hljs-string">&quot;Hello World!&quot;</span>);<br><br>app.Run();<br></code></pre></td></tr></table></figure><p>在 <code>ASP.NET Core</code> 中，<code>Serilog</code> 会自动记录应用程序的生命周期事件（如启动、停止）以及中间件的日志。</p><h1 id="日志上下文"><a href="#日志上下文" class="headerlink" title="日志上下文"></a>日志上下文</h1><p><code>Serilog</code> 支持日志上下文，可以在日志中添加上下文信息，例如用户 ID、请求 ID 等。以下是一个示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Serilog;<br><span class="hljs-keyword">using</span> Serilog.Context;<br><br>Log.Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()<br>    .WriteTo.Console()<br>    .CreateLogger();<br><br><span class="hljs-keyword">using</span> (LogContext.PushProperty(<span class="hljs-string">&quot;UserId&quot;</span>, <span class="hljs-number">12345</span>))<br>&#123;<br>    Log.Information(<span class="hljs-string">&quot;User &#123;UserId&#125; performed an action.&quot;</span>, <span class="hljs-number">12345</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在日志中，<code>UserId</code> 将作为上下文信息被记录。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Serilog</code> 是一个功能强大且灵活的日志库，适用于各种 <code>.NET</code> 应用程序。它支持多种日志输出目标和丰富的配置选项，可以满足不同的日志需求。通过合理配置 <code>Serilog</code>，可以方便地记录应用程序的运行日志，帮助开发人员进行调试和问题排查。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp String 格式说明符</title>
    <link href="/2025/05/18/C-Sharp-String-%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E%E7%AC%A6/"/>
    <url>/2025/05/18/C-Sharp-String-%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><p>在 <code>C#</code> 中，格式说明符用于定义字符串格式化时的输出格式。它们可以用于 <code>ToString</code> 方法、<code>String.Format</code> 方法以及字符串插值中。以下是一些常见的格式说明符及其用途：</p><h1 id="标准格式说明符"><a href="#标准格式说明符" class="headerlink" title="标准格式说明符"></a>标准格式说明符</h1><p>标准格式说明符是预定义的格式化规则，适用于常见的数据类型（如数字、日期时间等）。</p><h2 id="数字格式说明符"><a href="#数字格式说明符" class="headerlink" title="数字格式说明符"></a>数字格式说明符</h2><h3 id="C-或-c：货币格式"><a href="#C-或-c：货币格式" class="headerlink" title="C 或 c：货币格式"></a><code>C</code> 或 <code>c</code>：货币格式</h3><p>会根据当前文化区域设置显示货币符号。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> a = <span class="hljs-number">123123123.456123123</span>;<br>Console.WriteLine(a.ToString(<span class="hljs-string">&quot;C&quot;</span>));<span class="hljs-comment">// 输出：¥123,123,123.46</span><br>   <span class="hljs-comment">//（默认文化区域设置）</span><br></code></pre></td></tr></table></figure><h3 id="D-或-d：十进制数字格式"><a href="#D-或-d：十进制数字格式" class="headerlink" title="D 或 d：十进制数字格式"></a><code>D</code> 或 <code>d</code>：十进制数字格式</h3><p>显示整数的完整数字形式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">12345</span>;<br>Console.WriteLine(number.ToString(<span class="hljs-string">&quot;D&quot;</span>)); <span class="hljs-comment">// 输出：12345</span><br></code></pre></td></tr></table></figure><h3 id="E-或-e：科学计数法格式。"><a href="#E-或-e：科学计数法格式。" class="headerlink" title="E 或 e：科学计数法格式。"></a><code>E</code> 或 <code>e</code>：科学计数法格式。</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">123456789</span>;<br>Console.WriteLine(<span class="hljs-keyword">value</span>.ToString(<span class="hljs-string">&quot;E&quot;</span>)); <span class="hljs-comment">// 输出：1.234568E+08</span><br></code></pre></td></tr></table></figure><h3 id="F-或-f：固定点格式"><a href="#F-或-f：固定点格式" class="headerlink" title="F 或 f：固定点格式"></a><code>F</code> 或 <code>f</code>：固定点格式</h3><p>显示小数点后的固定位数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">123.45678</span>;<br>Console.WriteLine(<span class="hljs-keyword">value</span>.ToString(<span class="hljs-string">&quot;F2&quot;</span>)); <span class="hljs-comment">// 输出：123.46</span><br></code></pre></td></tr></table></figure><h3 id="G-或-g：常规格式"><a href="#G-或-g：常规格式" class="headerlink" title="G 或 g：常规格式"></a><code>G</code> 或 <code>g</code>：常规格式</h3><p>根据数字的大小和类型自动选择合适的格式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">123456789</span>;<br>Console.WriteLine(<span class="hljs-keyword">value</span>.ToString(<span class="hljs-string">&quot;G&quot;</span>)); <span class="hljs-comment">// 输出：123456789</span><br></code></pre></td></tr></table></figure><h3 id="N-或-n：数字格式"><a href="#N-或-n：数字格式" class="headerlink" title="N 或 n：数字格式"></a><code>N</code> 或 <code>n</code>：数字格式</h3><p>显示千位分隔符。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">123456789</span>;<br>Console.WriteLine(number.ToString(<span class="hljs-string">&quot;N&quot;</span>)); <span class="hljs-comment">// 输出：123,456,789</span><br></code></pre></td></tr></table></figure><h3 id="P-或-p：百分比格式"><a href="#P-或-p：百分比格式" class="headerlink" title="P 或 p：百分比格式"></a><code>P</code> 或 <code>p</code>：百分比格式</h3><p>将数字乘以 100 并显示百分号。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> percentage = <span class="hljs-number">0.12345</span>;<br>Console.WriteLine(percentage.ToString(<span class="hljs-string">&quot;P&quot;</span>)); <span class="hljs-comment">// 输出：12.35%</span><br></code></pre></td></tr></table></figure><h3 id="X-或-x：十六进制格式"><a href="#X-或-x：十六进制格式" class="headerlink" title="X 或 x：十六进制格式"></a><code>X</code> 或 <code>x</code>：十六进制格式</h3><p>显示数字的十六进制表示。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">255</span>;<br>Console.WriteLine(number.ToString(<span class="hljs-string">&quot;X&quot;</span>)); <span class="hljs-comment">// 输出：FF</span><br></code></pre></td></tr></table></figure><h2 id="日期时间格式说明符"><a href="#日期时间格式说明符" class="headerlink" title="日期时间格式说明符"></a>日期时间格式说明符</h2><h3 id="d：短日期格式"><a href="#d：短日期格式" class="headerlink" title="d：短日期格式"></a><code>d</code>：短日期格式</h3><p> <code>MM/dd/yyyy</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">DateTime now = DateTime.Now;<br>Console.WriteLine(now.ToString(<span class="hljs-string">&quot;d&quot;</span>)); <span class="hljs-comment">// 输出：05/18/2025</span><br></code></pre></td></tr></table></figure><h3 id="D：长日期格式"><a href="#D：长日期格式" class="headerlink" title="D：长日期格式"></a><code>D</code>：长日期格式</h3><p> <code>dddd</code>, <code>MMMM dd</code>, <code>yyyy</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;D&quot;</span>)); <span class="hljs-comment">// 输出：Sunday, May 18, 2025</span><br></code></pre></td></tr></table></figure><h3 id="t：短时间格式"><a href="#t：短时间格式" class="headerlink" title="t：短时间格式"></a><code>t</code>：短时间格式</h3><p> <code>HH:mm</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;t&quot;</span>)); <span class="hljs-comment">// 输出：14:30</span><br></code></pre></td></tr></table></figure><h3 id="T：长时间格式"><a href="#T：长时间格式" class="headerlink" title="T：长时间格式"></a><code>T</code>：长时间格式</h3><p> <code>HH:mm:ss</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;T&quot;</span>)); <span class="hljs-comment">// 输出：14:30:45</span><br></code></pre></td></tr></table></figure><h3 id="f：完整日期时间格式"><a href="#f：完整日期时间格式" class="headerlink" title="f：完整日期时间格式"></a><code>f</code>：完整日期时间格式</h3><p><code>短日期 + 长时间</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;f&quot;</span>)); <span class="hljs-comment">// 输出：2025年5月18日 20:07</span><br><br></code></pre></td></tr></table></figure><h3 id="F：完整日期时间格式"><a href="#F：完整日期时间格式" class="headerlink" title="F：完整日期时间格式"></a><code>F</code>：完整日期时间格式</h3><p><code>长日期 + 长时间</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;F&quot;</span>)); <span class="hljs-comment">// 输出：2025年5月18日 20:07:51</span><br><br></code></pre></td></tr></table></figure><h3 id="g：通用日期时间格式"><a href="#g：通用日期时间格式" class="headerlink" title="g：通用日期时间格式"></a><code>g</code>：通用日期时间格式</h3><p><code>短日期 + 短时间</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;g&quot;</span>)); <span class="hljs-comment">// 输出：2025/05/18 20:09</span><br><br></code></pre></td></tr></table></figure><h3 id="G：通用日期时间格式"><a href="#G：通用日期时间格式" class="headerlink" title="G：通用日期时间格式"></a><code>G</code>：通用日期时间格式</h3><p><code>短日期 + 长时间</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;G&quot;</span>)); <span class="hljs-comment">// 输出：2025/05/18 20:08:23</span><br><br><br></code></pre></td></tr></table></figure><h3 id="u：通用排序格式"><a href="#u：通用排序格式" class="headerlink" title="u：通用排序格式"></a><code>u</code>：通用排序格式</h3><p><code>yyyy-MM-dd HH:mm:ssZ</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;u&quot;</span>)); <span class="hljs-comment">// 输出：2025-05-18 20:08:44Z</span><br><br></code></pre></td></tr></table></figure><h3 id="U：通用排序格式"><a href="#U：通用排序格式" class="headerlink" title="U：通用排序格式"></a><code>U</code>：通用排序格式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;u&quot;</span>)); <span class="hljs-comment">// 输出：2025年5月18日 12:10:17</span><br><br><br></code></pre></td></tr></table></figure><h1 id="自定义格式说明符"><a href="#自定义格式说明符" class="headerlink" title="自定义格式说明符"></a>自定义格式说明符</h1><p>自定义格式说明符允许你定义自己的格式规则，适用于数字和日期时间类型。</p><h2 id="自定义数字格式说明符"><a href="#自定义数字格式说明符" class="headerlink" title="自定义数字格式说明符"></a>自定义数字格式说明符</h2><h3 id="0：占位符，表示数字位"><a href="#0：占位符，表示数字位" class="headerlink" title="0：占位符，表示数字位"></a><code>0</code>：占位符，表示数字位</h3><p>如果数字不足，会用零填充。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">123</span>;<br>Console.WriteLine(number.ToString(<span class="hljs-string">&quot;00000&quot;</span>)); <span class="hljs-comment">// 输出：00123</span><br></code></pre></td></tr></table></figure><h3 id="：占位符，表示数字位"><a href="#：占位符，表示数字位" class="headerlink" title="#：占位符，表示数字位"></a><code>#</code>：占位符，表示数字位</h3><p>如果数字不足，不会填充。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">123</span>;<br>Console.WriteLine(number.ToString(<span class="hljs-string">&quot;#####&quot;</span>)); <span class="hljs-comment">// 输出：123</span><br></code></pre></td></tr></table></figure><hr><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123456.12</span>;<br>Console.WriteLine(a.ToString(<span class="hljs-string">&quot;#000.#00&quot;</span>)); <span class="hljs-comment">// 输出：123456.120</span><br>Console.WriteLine(a.ToString(<span class="hljs-string">&quot;#000.00#&quot;</span>)); <span class="hljs-comment">// 输出：123456.12</span><br><br></code></pre></td></tr></table></figure><ul><li><code>#</code>用于避免显示多余的零。</li><li><code>0</code>用于确保格式化后的字符串长度固定。</li></ul><hr><h3 id="：小数点分隔符"><a href="#：小数点分隔符" class="headerlink" title=".：小数点分隔符"></a><code>.</code>：小数点分隔符</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">123.456</span>;<br>Console.WriteLine(<span class="hljs-keyword">value</span>.ToString(<span class="hljs-string">&quot;0.00&quot;</span>)); <span class="hljs-comment">// 输出：123.46</span><br></code></pre></td></tr></table></figure><h3 id="：千位分隔符"><a href="#：千位分隔符" class="headerlink" title=",：千位分隔符"></a><code>,</code>：千位分隔符</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">123456789</span>;<br>Console.WriteLine(number.ToString(<span class="hljs-string">&quot;#,##0&quot;</span>)); <span class="hljs-comment">// 输出：123,456,789</span><br></code></pre></td></tr></table></figure><h2 id="自定义日期时间格式说明符"><a href="#自定义日期时间格式说明符" class="headerlink" title="自定义日期时间格式说明符"></a>自定义日期时间格式说明符</h2><h3 id="yyyy：四位年份"><a href="#yyyy：四位年份" class="headerlink" title="yyyy：四位年份"></a><code>yyyy</code>：四位年份</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">DateTime now = DateTime.Now;<br>Console.WriteLine(now.ToString(<span class="hljs-string">&quot;yyyy&quot;</span>)); <span class="hljs-comment">// 输出：2025</span><br></code></pre></td></tr></table></figure><h3 id="MM：两位月份"><a href="#MM：两位月份" class="headerlink" title="MM：两位月份"></a><code>MM</code>：两位月份</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;MM&quot;</span>)); <span class="hljs-comment">// 输出：05</span><br></code></pre></td></tr></table></figure><h3 id="dd：两位日期"><a href="#dd：两位日期" class="headerlink" title="dd：两位日期"></a><code>dd</code>：两位日期</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;dd&quot;</span>)); <span class="hljs-comment">// 输出：18</span><br></code></pre></td></tr></table></figure><h3 id="HH：两位24小时制的小时"><a href="#HH：两位24小时制的小时" class="headerlink" title="HH：两位24小时制的小时"></a><code>HH</code>：两位24小时制的小时</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;HH&quot;</span>)); <span class="hljs-comment">// 输出：14</span><br></code></pre></td></tr></table></figure><h3 id="mm：两位分钟"><a href="#mm：两位分钟" class="headerlink" title="mm：两位分钟"></a><code>mm</code>：两位分钟</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;mm&quot;</span>)); <span class="hljs-comment">// 输出：30</span><br></code></pre></td></tr></table></figure><h3 id="ss：两位秒"><a href="#ss：两位秒" class="headerlink" title="ss：两位秒"></a><code>ss</code>：两位秒</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;ss&quot;</span>)); <span class="hljs-comment">// 输出：45</span><br></code></pre></td></tr></table></figure><h3 id="fff：三位毫秒"><a href="#fff：三位毫秒" class="headerlink" title="fff：三位毫秒"></a><code>fff</code>：三位毫秒</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(now.ToString(<span class="hljs-string">&quot;fff&quot;</span>)); <span class="hljs-comment">// 输出：123</span><br></code></pre></td></tr></table></figure><h1 id="格式说明符的使用示例"><a href="#格式说明符的使用示例" class="headerlink" title="格式说明符的使用示例"></a>格式说明符的使用示例</h1><p>以下是一些综合示例，展示如何在不同场景中使用格式说明符。</p><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> price = <span class="hljs-number">123.456</span>;<br><span class="hljs-built_in">int</span> quantity = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">string</span> formatted = String.Format(<span class="hljs-string">&quot;The price is &#123;0:C&#125; and the quantity is &#123;1:N&#125;&quot;</span>, price, quantity);<br>Console.WriteLine(formatted); <span class="hljs-comment">// 输出：The price is $123.46 and the quantity is 10</span><br></code></pre></td></tr></table></figure><h2 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> price = <span class="hljs-number">123.456</span>;<br><span class="hljs-built_in">int</span> quantity = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">string</span> interpolated = <span class="hljs-string">$&quot;The price is <span class="hljs-subst">&#123;price:C&#125;</span> and the quantity is <span class="hljs-subst">&#123;quantity:N&#125;</span>&quot;</span>;<br>Console.WriteLine(interpolated); <span class="hljs-comment">// 输出：The price is $123.46 and the quantity is 10</span><br></code></pre></td></tr></table></figure><h2 id="日期时间格式化"><a href="#日期时间格式化" class="headerlink" title="日期时间格式化"></a>日期时间格式化</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">DateTime now = DateTime.Now;<br><span class="hljs-built_in">string</span> formattedDate = now.ToString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>Console.WriteLine(formattedDate); <span class="hljs-comment">// 输出：2025-05-18 14:30:45</span><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>格式说明符是 <code>C#</code> 中用于控制字符串格式化的强大工具。标准格式说明符适用于常见的格式化需求，而自定义格式说明符则提供了更高的灵活性。通过合理使用这些格式说明符，你可以生成符合需求的字符串输出。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp AppContext.BaseDirectory 应用程序的启动目录</title>
    <link href="/2025/04/22/C-Sharp-AppContext-BaseDirectory-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/"/>
    <url>/2025/04/22/C-Sharp-AppContext-BaseDirectory-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><blockquote><p>注意AppContext.BaseDirectory结尾带  \</p></blockquote><blockquote><p>可用AppContext.BaseDirectory.TrimEnd(System.IO.Path.DirectorySeparatorChar)去除</p></blockquote><hr><p>在<code>C# WinForms</code>应用中，<code>Application.StartupPath</code>、<code>Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)</code> 和 <code>Directory.GetCurrentDirectory()</code> 是三种获取路径的常用方法，但它们在行为、用途和局限性上有显著差异。以下是详细的对比分析：</p><h1 id="Application-StartupPath"><a href="#Application-StartupPath" class="headerlink" title="Application.StartupPath"></a><code>Application.StartupPath</code></h1><h2 id="定义与用途"><a href="#定义与用途" class="headerlink" title="定义与用途"></a>定义与用途</h2><ul><li><p>命名空间: <code>System.Windows.Forms</code></p></li><li><p>返回值: 应用程序启动时的可执行文件（<code>.exe</code>）所在目录的绝对路径。</p></li><li><p>典型场景: 获取应用程序的安装目录（如配置文件、资源文件的路径）。</p></li></ul><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul><li><p>仅限<code>WinForms</code>应用: 依赖<code>System.Windows.Forms</code>，不适用于非<code>WinForms</code>项目（如控制台应用、<code>ASP.NET</code>）。</p></li><li><p><code>ClickOnce</code>部署问题: 若应用通过<code>ClickOnce</code>发布，返回的是临时缓存路径（如<code>AppData\Local\Apps\...</code>），而非原始安装路径。</p></li><li><p>快捷方式影响: 即使通过快捷方式启动且修改了“工作目录”，此属性仍返回<code>.exe</code>所在目录，不受工作目录影响。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> startupPath = Application.StartupPath; <br><span class="hljs-comment">// 例如：C:\MyApp\bin\Debug</span><br></code></pre></td></tr></table></figure><h1 id="Path-GetDirectoryName-Assembly-GetExecutingAssembly-Location"><a href="#Path-GetDirectoryName-Assembly-GetExecutingAssembly-Location" class="headerlink" title="Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)"></a><code>Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)</code></h1><h2 id="定义与用途-1"><a href="#定义与用途-1" class="headerlink" title="定义与用途"></a>定义与用途</h2><ul><li><p>命名空间: <code>System.Reflection</code>（<code>Assembly</code>类）、<code>System.IO</code>（<code>Path</code>类）</p></li><li><p>返回值: 当前执行程序集（<code>.exe</code>或<code>.dll</code>）的物理路径的目录部分。</p></li><li><p>典型场景: <em><strong>精确获取程序集的真实路径（无论是否被重定向或缓存）</strong></em>。</p></li></ul><h2 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h2><ul><li><p><code>Shadow Copy</code>影响: 在<code>ASP.NET</code>或插件系统中，程序集可能被“影子复制”到临时目录，此时<code>Location</code>返回的是临时路径。</p></li><li><p>网络加载问题: 若程序集从网络或字节流加载，<code>Location</code>可能不可用或返回空值。</p></li><li><p>权限要求: 需要文件系统访问权限，某些沙盒环境可能受限。</p></li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> assemblyPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);<br><span class="hljs-comment">// 例如：C:\MyApp\bin\Debug</span><br></code></pre></td></tr></table></figure><h1 id="Directory-GetCurrentDirectory"><a href="#Directory-GetCurrentDirectory" class="headerlink" title="Directory.GetCurrentDirectory()"></a>Directory.GetCurrentDirectory()</h1><h2 id="定义与用途-2"><a href="#定义与用途-2" class="headerlink" title="定义与用途"></a>定义与用途</h2><ul><li><p>命名空间: <code>System.IO</code></p></li><li><p>返回值: 进程的当前工作目录（可通过<code>Environment.CurrentDirectory</code>修改）。</p></li><li><p>典型场景: 获取&#x2F;设置应用程序运行时的上下文目录（如读取用户选择的文件）。</p></li></ul><h2 id="局限性-2"><a href="#局限性-2" class="headerlink" title="局限性"></a>局限性</h2><ul><li><p>易变性: 当前目录可能被代码（<code>Environment.CurrentDirectory</code>）或外部进程（如通过快捷方式启动时设置的“起始位置”）改变。</p></li><li><p>不可靠性: 多线程环境中，若某线程修改了当前目录，会影响所有线程的结果。</p></li><li><p>部署无关性: 与应用程序安装路径无关，仅反映运行时的工作目录。</p></li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> currentDir = Directory.GetCurrentDirectory();<br><span class="hljs-comment">// 可能为 C:\MyApp\bin\Debug（默认），或通过代码/启动方式修改后的路径。</span><br></code></pre></td></tr></table></figure><hr><h1 id="关键区别总结"><a href="#关键区别总结" class="headerlink" title="关键区别总结"></a>关键区别总结</h1><table><thead><tr><th>特性</th><th>Application.StartupPath</th><th>Assembly.Location</th><th>Directory.GetCurrentDirectory()</th></tr></thead><tbody><tr><td><strong>数据源</strong></td><td>应用程序启动路径</td><td>程序集物理路径</td><td>进程当前工作目录</td></tr><tr><td><strong>部署敏感</strong></td><td>受ClickOnce影响</td><td>受Shadow Copy&#x2F;网络加载影响</td><td>与部署无关</td></tr><tr><td><strong>可变性</strong></td><td>固定（启动后不变）</td><td>固定（程序集路径不变）</td><td>动态（可被代码或外部修改）</td></tr><tr><td><strong>适用场景</strong></td><td>WinForms安装目录</td><td>精确获取程序集路径</td><td>运行时工作目录</td></tr><tr><td><strong>跨平台兼容性</strong></td><td>仅Windows&#x2F;WinForms</td><td>全平台（.NET Core&#x2F;5+）</td><td>全平台</td></tr></tbody></table><h1 id="推荐使用场景"><a href="#推荐使用场景" class="headerlink" title="推荐使用场景"></a>推荐使用场景</h1><h3 id="需要应用程序安装目录"><a href="#需要应用程序安装目录" class="headerlink" title="需要应用程序安装目录"></a>需要应用程序安装目录</h3><p>优先使用 <code>Assembly.GetExecutingAssembly().Location</code>（跨平台兼容）。</p><p><code>WinForms</code>专用场景可用 <code>Application.StartupPath</code>，但需注意<code>ClickOnce</code>问题。</p><h3 id="需要动态工作目录"><a href="#需要动态工作目录" class="headerlink" title="需要动态工作目录"></a>需要动态工作目录</h3><p>使用 Directory.GetCurrentDirectory()，但需明确其可变性，避免依赖它存储关键路径。</p><h3 id="插件或模块化应用"><a href="#插件或模块化应用" class="headerlink" title="插件或模块化应用"></a>插件或模块化应用</h3><p>对加载的插件程序集使用 Assembly.Location，注意处理Shadow Copy场景。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><blockquote><p>Q: ClickOnce部署时如何获取真实安装路径？</p></blockquote><blockquote><p>A:<br>使用ApplicationDeployment.CurrentDeployment.ActivationUri（需检查部署状态），但需处理非ClickOnce场景的回退逻辑。</p></blockquote><hr><blockquote><p>Q: 如何安全地组合路径？</p></blockquote><blockquote><p>A: 始终使用Path.Combine()而非字符串拼接，避免跨平台路径分隔符问题：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> configPath = Path.Combine(<br>    Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),<br>    <span class="hljs-string">&quot;Config&quot;</span>,<br>    <span class="hljs-string">&quot;appsettings.json&quot;</span><br>);<br></code></pre></td></tr></table></figure><hr><blockquote><p>Q: 在ASP.NET Core中如何替代？</p></blockquote><blockquote><p>A: 使用IWebHostEnvironment.ContentRootPath或AppContext.BaseDirectory替代。</p></blockquote><hr><p>通过理解这些方法的差异和局限性，可以避免路径相关的常见陷阱（如文件未找到、权限错误），确保应用在不同环境中稳定运行。</p><h1 id="很快啊-又发现个新的"><a href="#很快啊-又发现个新的" class="headerlink" title="很快啊 又发现个新的"></a>很快啊 又发现个新的</h1><h2 id="AppContext-BaseDirectory"><a href="#AppContext-BaseDirectory" class="headerlink" title="AppContext.BaseDirectory"></a><code>AppContext.BaseDirectory</code></h2><h3 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h3><p> <code>AppContext.BaseDirectory</code></p><ul><li>功能：获取程序集解析程序用于探测程序集的基目录的文件路径。</li><li>特点：返回的是应用程序的根目录，通常对应于应用程序的启动目录。</li><li>跨平台性：在 <code>.NET Core</code> 和 <code>.NET 5+</code> 中，它是一个跨平台的首选方式，适用于各种操作系统。</li></ul><p><code>System.IO.Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)</code></p><ul><li>功能：获取当前正在执行的程序集所在的目录。</li><li>特点：返回的是当前程序集的物理路径所在的目录。</li><li>跨平台性：虽然也是跨平台的，但它的行为可能因程序集的部署方式（如影子复制、嵌入式资源等）而有所不同。</li></ul><h3 id="返回值的区别"><a href="#返回值的区别" class="headerlink" title="返回值的区别"></a>返回值的区别</h3><p><code>AppContext.BaseDirectory</code></p><ul><li>返回的是应用程序的启动目录，即应用程序启动时所在的目录。<br>例如，如果应用程序是从某个可执行文件启动的，那么返回的就是该可执行文件所在的目录。</li></ul><p><code>System.IO.Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)</code></p><ul><li>返回的是当前正在执行的程序集所在的目录。<br>如果程序集被影子复制（Shadow Copying），则返回的是影子复制后的目录，而不是原始程序集所在的目录。<br>如果程序集是嵌入式资源（如在某些打包工具中），则可能返回的是临时解压后的目录。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>AppContext.BaseDirectory</code></p><ul><li>适用场景：当需要获取应用程序的根目录时，尤其是当应用程序的启动目录和程序集所在的目录一致时。</li><li>优点：更稳定，不受程序集部署方式的影响，是跨平台的首选方式。</li><li>示例：在 <code>ASP.NET Core</code> 应用程序中，<code>AppContext.BaseDirectory</code> 可以用来获取应用程序的根目录，用于加载配置文件、日志文件等。</li><li></li></ul><p><code>System.IO.Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)</code></p><ul><li>适用场景：当需要获取当前程序集的具体路径时，尤其是在程序集可能被影子复制或嵌入式部署的场景中。</li><li>优点：可以精确地获取当前程序集的实际路径。</li><li>缺点：在某些情况下（如影子复制），返回的路径可能不是原始路径，需要额外处理。</li><li>示例：在某些需要动态加载程序集的场景中，可能需要使用 <code>Assembly.GetExecutingAssembly().Location</code> 来获取程序集的实际路径。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp CancellationTokenSource CancellationToken Task.Run传入token 取消令牌</title>
    <link href="/2025/03/24/C-Sharp-CancellationTokenSource-CancellationToken-Task-Run%E4%BC%A0%E5%85%A5token-%E5%8F%96%E6%B6%88%E4%BB%A4%E7%89%8C/"/>
    <url>/2025/03/24/C-Sharp-CancellationTokenSource-CancellationToken-Task-Run%E4%BC%A0%E5%85%A5token-%E5%8F%96%E6%B6%88%E4%BB%A4%E7%89%8C/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><p><code>CancellationTokenSource</code> 是 <code>C#</code> 中用于实现异步操作取消的核心类，它生成 <code>CancellationToken</code> 对象，该对象可以传递给异步方法，并在异步方法内部检查是否收到取消请求。</p><h1 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h1><h2 id="创建-CancellationTokenSource"><a href="#创建-CancellationTokenSource" class="headerlink" title="创建 CancellationTokenSource"></a>创建 <code>CancellationTokenSource</code></h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<br></code></pre></td></tr></table></figure><h2 id="获取-CancellationToken"><a href="#获取-CancellationToken" class="headerlink" title="获取 CancellationToken"></a>获取 <code>CancellationToken</code></h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">CancellationToken token = cts.Token;<br></code></pre></td></tr></table></figure><h2 id="将-CancellationToken-传递给任务"><a href="#将-CancellationToken-传递给任务" class="headerlink" title="将 CancellationToken 传递给任务"></a>将 <code>CancellationToken</code> 传递给任务</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Task task = Task.Run(() =&gt; DoWork(token), token);<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><em><strong>注意</strong></em></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 传递给</span><br>Task.Run(() =&gt; &#123;<br>Foo();<br>&#125;, token);<br><span class="hljs-comment">// 的token只是在Task开始运行前检查一次是否取消，如果取消，Run不了一点</span><br></code></pre></td></tr></table></figure><h2 id="在任务中检查取消状态"><a href="#在任务中检查取消状态" class="headerlink" title="在任务中检查取消状态"></a>在任务中检查取消状态</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoWork</span>(<span class="hljs-params">CancellationToken token</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>    <span class="hljs-comment">// 检查是否收到取消请求</span><br>         <span class="hljs-keyword">if</span> (token.IsCancellationRequested)<br>        token.ThrowIfCancellationRequested();<span class="hljs-comment">// 此处抛出异常，外面用try catch捕获</span><br>        <br>        Console.WriteLine(<span class="hljs-string">$&quot;Task working... <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟耗时操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="请求取消"><a href="#请求取消" class="headerlink" title="请求取消"></a>请求取消</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">cts.Cancel();<br></code></pre></td></tr></table></figure><h2 id="处理取消异常"><a href="#处理取消异常" class="headerlink" title="处理取消异常"></a>处理取消异常</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-keyword">await</span> task;<br>&#125;<br><span class="hljs-keyword">catch</span> (OperationCanceledException)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Task was cancelled.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><h2 id="设置超时自动取消"><a href="#设置超时自动取消" class="headerlink" title="设置超时自动取消"></a>设置超时自动取消</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 5秒后自动取消</span><br>CancellationToken token = cts.Token;<br></code></pre></td></tr></table></figure><h2 id="或者使用-CancelAfter-方法"><a href="#或者使用-CancelAfter-方法" class="headerlink" title="或者使用 CancelAfter 方法"></a>或者使用 <code>CancelAfter</code> 方法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<br>cts.CancelAfter(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 5秒后自动取消</span><br></code></pre></td></tr></table></figure><h2 id="关联多个取消令牌"><a href="#关联多个取消令牌" class="headerlink" title="关联多个取消令牌"></a>关联多个取消令牌</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp">CancellationTokenSource tokenSource1 = <span class="hljs-keyword">new</span> CancellationTokenSource();<br>CancellationTokenSource tokenSource2 = <span class="hljs-keyword">new</span> CancellationTokenSource();<br><br>CancellationTokenSource linkedTokenSource =<br>CancellationTokenSource.CreateLinkedTokenSource(<br>tokenSource1.Token, <br>tokenSource2.Token<br>);<br><br>linkedTokenSource.Token.Register(() =&gt; <br>Console.WriteLine(<span class="hljs-string">&quot;Linked token cancelled&quot;</span>)<br>);<br><br>tokenSource1.Cancel(); <span class="hljs-comment">// 会触发 linkedTokenSource 的取消</span><br></code></pre></td></tr></table></figure><h2 id="注册回调"><a href="#注册回调" class="headerlink" title="注册回调"></a>注册回调</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">token.Register(() =&gt; Console.WriteLine(<span class="hljs-string">&quot;Cancellation requested&quot;</span>));<br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>取消操作是协作式的，任务必须主动检查 <code>CancellationToken</code> 的状态。</li><li><code>CancellationTokenSource</code> 的 <code>Cancel</code> 方法会触发所有注册的回调。</li><li>默认情况下，<code>CancellationTokenSource</code> 是一次性的，取消后无法重置。</li></ul><hr><p>通过这些方法，<code>CancellationTokenSource</code> 可以有效地管理异步操作的取消。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp Channel</title>
    <link href="/2025/03/10/C-Sharp-Channel/"/>
    <url>/2025/03/10/C-Sharp-Channel/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><p>在<code>C#</code>中，<code>System.Threading.Channels</code> 提供了<em><strong>高效的异步生产-消费模型</strong></em>，适用于多任务间的数据传递。以下是其核心概念及使用方法的总结：</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p><code>Channel&lt;T&gt;</code>：异步消息队列，支持多生产者和多消费者。</p><p><code>ChannelWriter&lt;T&gt;</code>：用于异步写入数据（<code>WriteAsync</code>），完成后需调用 <code>Complete()</code>。</p><p><code>ChannelReader&lt;T&gt;</code>：用于异步读取数据，支持 <code>ReadAsync</code> 或 <code>ReadAllAsync</code> 遍历。</p><h1 id="创建Channel"><a href="#创建Channel" class="headerlink" title="创建Channel"></a>创建Channel</h1><h2 id="无界通道"><a href="#无界通道" class="headerlink" title="无界通道"></a>无界通道</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">var channel = Channel.CreateUnbounded&lt;<span class="hljs-type">int</span>&gt;();<br></code></pre></td></tr></table></figure><p>容量无限，适用于不确定数据量的场景。</p><h2 id="有界通道"><a href="#有界通道" class="headerlink" title="有界通道"></a>有界通道</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">var options = new BoundedChannelOptions(<span class="hljs-number">10</span>)<br>&#123;<br>    FullMode = BoundedChannelFullMode.Wait <span class="hljs-comment">// 满时等待</span><br>&#125;;<br>var channel = Channel.CreateBounded&lt;<span class="hljs-type">int</span>&gt;(options);<br></code></pre></td></tr></table></figure><h3 id="FullMode选项"><a href="#FullMode选项" class="headerlink" title="FullMode选项"></a><code>FullMode</code>选项</h3><ul><li><p><code>Wait</code>（默认）：写入时阻塞直到有空间。</p></li><li><p><code>DropOldest</code>&#x2F;<code>DropNewest</code>：丢弃最旧&#x2F;最新数据。</p></li><li><p><code>DropWrite</code>：丢弃当前写入的数据。</p></li></ul><h1 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h1><h2 id="生产者写入数据"><a href="#生产者写入数据" class="headerlink" title="生产者写入数据"></a>生产者写入数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">async Task <span class="hljs-title function_">Producer</span><span class="hljs-params">(ChannelWriter&lt;<span class="hljs-type">int</span>&gt; writer)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        await writer.WriteAsync(i);<br>        await Task.Delay(<span class="hljs-number">100</span>);<br>    &#125;<br>    writer.Complete(); <span class="hljs-comment">// 标记完成</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者读取数据"><a href="#消费者读取数据" class="headerlink" title="消费者读取数据"></a>消费者读取数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">async Task <span class="hljs-title function_">Consumer</span><span class="hljs-params">(ChannelReader&lt;<span class="hljs-type">int</span>&gt; reader)</span><br>&#123;<br>    <span class="hljs-comment">// 方式1: ReadAllAsync遍历</span><br>    await <span class="hljs-title function_">foreach</span> <span class="hljs-params">(var item in reader.ReadAllAsync())</span><br>    &#123;<br>        Console.WriteLine($<span class="hljs-string">&quot;Received: &#123;item&#125;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 方式2: 手动循环</span><br>    <span class="hljs-keyword">while</span> (await reader.WaitToReadAsync())<br>    &#123;<br>        <span class="hljs-keyword">while</span> (reader.TryRead(out var item))<br>        &#123;<br>            Console.WriteLine($<span class="hljs-string">&quot;Received: &#123;item&#125;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">using System;<br>using System.Threading.Channels;<br>using System.Threading.Tasks;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">static</span> async Task <span class="hljs-title function_">Main</span><span class="hljs-params">()</span><br>    &#123;<br>        var channel = Channel.CreateUnbounded&lt;<span class="hljs-type">int</span>&gt;();<br><br>        var producer = Producer(channel.Writer);<br>        var consumer = Consumer(channel.Reader);<br><br>        await Task.WhenAll(producer, consumer);<br>    &#125;<br><br>    <span class="hljs-type">static</span> async Task <span class="hljs-title function_">Producer</span><span class="hljs-params">(ChannelWriter&lt;<span class="hljs-type">int</span>&gt; writer)</span><br>    &#123;<br>        try<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>            &#123;<br>                await writer.WriteAsync(i);<br>                await Task.Delay(<span class="hljs-number">100</span>);<br>            &#125;<br>        &#125;<br>        catch (Exception ex)<br>        &#123;<br>            writer.Complete(ex); <span class="hljs-comment">// 传递异常</span><br>        &#125;<br>        finally<br>        &#123;<br>            writer.Complete();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">static</span> async Task <span class="hljs-title function_">Consumer</span><span class="hljs-params">(ChannelReader&lt;<span class="hljs-type">int</span>&gt; reader)</span><br>    &#123;<br>        try<br>        &#123;<br>            await <span class="hljs-title function_">foreach</span> <span class="hljs-params">(var item in reader.ReadAllAsync())</span><br>            &#123;<br>                Console.WriteLine($<span class="hljs-string">&quot;Processed: &#123;item&#125;&quot;</span>);<br>            &#125;<br>        &#125;<br>        catch (Exception ex)<br>        &#123;<br>            Console.WriteLine($<span class="hljs-string">&quot;Error: &#123;ex.Message&#125;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h1><h2 id="优化选项："><a href="#优化选项：" class="headerlink" title="优化选项："></a>优化选项：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">var options = new UnboundedChannelOptions()<br>&#123;<br>    SingleWriter = <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 单一生产者优化</span><br>    SingleReader = <span class="hljs-literal">false</span>  <span class="hljs-comment">// 允许多消费者</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="取消操作：通过-CancellationToken-取消读写。"><a href="#取消操作：通过-CancellationToken-取消读写。" class="headerlink" title="取消操作：通过 CancellationToken 取消读写。"></a>取消操作：通过 <code>CancellationToken</code> 取消读写。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">await writer.WriteAsync(item, cancellationToken);<br></code></pre></td></tr></table></figure><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>生产者异常时，调用 <code>writer.Complete(ex)</code> 通知消费者。</p><p>消费者通过 <code>try-catch</code> 捕获遍历时的异常。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>数据流水线处理。</p><p>高吞吐量的异步任务。</p><p>多任务间的负载均衡。</p><hr><p>在<code>C#</code>中，<code>System.Threading.Channels</code> 是一个强大的异步通信机制，主要用于实现生产者-消费者模式。它提供了线程安全的通道（<code>Channel</code>），用于在不同线程之间传递数据。以下是关于<code>C# Channel</code>的详细介绍：</p><h1 id="Channel的类型"><a href="#Channel的类型" class="headerlink" title="Channel的类型"></a><code>Channel</code>的类型</h1><p><code>Channel</code>有两种类型：<br>有界通道（<code>Bounded Channel</code>）：具有固定容量，当通道已满时，可以根据指定的策略处理新消息。<br>无界通道（<code>Unbounded Channel</code>）：没有容量限制，适合生产者和消费者速度匹配的场景。</p><h1 id="创建Channel-1"><a href="#创建Channel-1" class="headerlink" title="创建Channel"></a>创建<code>Channel</code></h1><p>使用<code>Channel.CreateBounded&lt;T&gt;</code>创建有界通道，需要指定容量和满时的处理策略（如<code>Wait</code>、<code>DropNewest</code>、<code>DropOldest</code>等）。<br>使用<code>Channel.CreateUnbounded&lt;T&gt;</code>创建无界通道。</p><h1 id="写入和读取消息"><a href="#写入和读取消息" class="headerlink" title="写入和读取消息"></a>写入和读取消息</h1><p>生产者通过<code>channel.Writer.WriteAsync()</code>方法写入消息。<br>消费者通过<code>channel.Reader.ReadAsync()</code>或<code>channel.Reader.WaitToReadAsync()</code>读取消息。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><code>Channel</code>主要用于生产者-消费者模式，可以实现高效的异步数据处理。它支持多线程操作，并可以通过<code>SingleReader</code>和<code>SingleWriter</code>属性限制通道的读写行为。</p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>以下是一个简单的生产者-消费者示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">var channel = Channel.CreateBounded&lt;<span class="hljs-type">int</span>&gt;(new BoundedChannelOptions(<span class="hljs-number">10</span>)<br>&#123;<br>    FullMode = BoundedChannelFullMode.Wait<br>&#125;);<br><br>Task producer = Task.Run(async () =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        await channel.Writer.WriteAsync(i);<br>        Console.WriteLine($<span class="hljs-string">&quot;Produced: &#123;i&#125;&quot;</span>);<br>    &#125;<br>    channel.Writer.Complete();<br>&#125;);<br><br>Task consumer = Task.Run(async () =&gt;<br>&#123;<br>    <span class="hljs-keyword">while</span> (await channel.Reader.WaitToReadAsync())<br>    &#123;<br>        <span class="hljs-keyword">if</span> (channel.Reader.TryRead(out var item))<br>        &#123;<br>            Console.WriteLine($<span class="hljs-string">&quot;Consumed: &#123;item&#125;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br><br>await Task.WhenAll(producer, consumer);<br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>缓冲区溢出：生产者写入速度过快可能导致缓冲区溢出。</li><li>正确关闭<code>Channel</code>：在数据完全消费后关闭<code>Channel</code>，避免数据丢失。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp BlockingCollection</title>
    <link href="/2025/03/10/C-Sharp-BlockingCollection/"/>
    <url>/2025/03/10/C-Sharp-BlockingCollection/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><p><code>BlockingCollection&lt;T&gt;</code> 是 <code>C#</code> 中一个非常有用的线程安全集合类，位于 <code>System.Collections.Concurrent</code> 命名空间中。它主要用于在多线程环境中实现<em><strong>线程安全的生产者-消费者模式</strong></em>。<br>以下是关于 <code>BlockingCollection&lt;T&gt;</code> 的详细介绍：</p><h1 id="什么是-BlockingCollection"><a href="#什么是-BlockingCollection" class="headerlink" title="什么是 BlockingCollection&lt;T&gt;"></a>什么是 <code>BlockingCollection&lt;T&gt;</code></h1><p><code>BlockingCollection&lt;T&gt;</code> 是一个线程安全的集合，它提供了一种机制，允许一个或多个生产者线程将数据添加到集合中，同时允许一个或多个消费者线程从集合中取出数据。它内部封装了一个线程安全的集合（如 <code>ConcurrentQueue&lt;T&gt;</code>、<code>ConcurrentStack&lt;T&gt;</code> 或 <code>ConcurrentBag&lt;T&gt;</code>），并提供了阻塞和限制集合大小的功能。</p><h1 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h1><ul><li>线程安全：内部使用锁或其他同步机制，确保在多线程环境下对集合的操作是安全的。</li><li>阻塞操作：当集合为空时，消费者线程会阻塞等待，直到有数据可用；当集合达到最大容量时，生产者线程会阻塞等待，直到有空间可用。</li><li>限制大小：可以通过构造函数指定集合的最大容量。</li><li>支持多种底层集合：可以使用 <code>ConcurrentQueue&lt;T&gt;</code>（默认）、<code>ConcurrentStack&lt;T&gt;</code> 或 <code>ConcurrentBag&lt;T&gt;</code> 作为底层存储结构。</li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><code>BlockingCollection&lt;T&gt;</code> 提供了多种构造方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 使用默认的 ConcurrentQueue&lt;T&gt;，无容量限制</span><br>var blockingCollection = new BlockingCollection&lt;<span class="hljs-type">int</span>&gt;();<br><br><span class="hljs-comment">// 使用默认的 ConcurrentQueue&lt;T&gt;，并指定最大容量</span><br>var blockingCollection = new BlockingCollection&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 指定底层集合类型</span><br>var blockingCollection = new BlockingCollection&lt;<span class="hljs-type">int</span>&gt;(new ConcurrentStack&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="生产者操作"><a href="#生产者操作" class="headerlink" title="生产者操作"></a>生产者操作</h2><p><code>Add(T item)</code>：将一个元素添加到集合中。如果集合已满，会抛出异常。<br><code>TryAdd(T item)</code>：尝试将一个元素添加到集合中。如果集合已满，返回 <code>false</code>。<br><code>TryAdd(T item, TimeSpan timeout)</code>：尝试在指定的超时时间内将元素添加到集合中。<br><code>CompleteAdding()</code>：标记集合不再添加新的元素。消费者线程在集合为空时会收到通知并退出。</p><h2 id="消费者操作"><a href="#消费者操作" class="headerlink" title="消费者操作"></a>消费者操作</h2><p><code>Take()</code>：从集合中取出一个元素。如果集合为空，线程会阻塞等待。<br><code>TryTake(out T item)</code>：尝试从集合中取出一个元素。如果集合为空，返回 <code>false</code>。<br><code>TryTake(out T item, TimeSpan timeout)</code>：尝试在指定的超时时间内从集合中取出一个元素。<br><code>GetConsumingEnumerable()</code>：返回一个可枚举的集合，消费者可以使用 <code>foreach</code> 遍历集合中的元素。当调用 <code>CompleteAdding()</code> 后，枚举会结束。</p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>以下是一个简单的生产者-消费者示例，使用 <code>BlockingCollection&lt;T&gt;</code> 实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">using System;<br>using System.Collections.Concurrent;<br>using System.Threading;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Main</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个容量为 5 的 BlockingCollection</span><br>        var blockingCollection = new BlockingCollection&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 启动生产者线程</span><br>        Thread producerThread = new Thread(() =&gt;<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)<br>            &#123;<br>                blockingCollection.Add(i); <span class="hljs-comment">// 添加元素</span><br>                Console.WriteLine($<span class="hljs-string">&quot;Producer added: &#123;i&#125;&quot;</span>);<br>                Thread.Sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟生产时间</span><br>            &#125;<br>            blockingCollection.CompleteAdding(); <span class="hljs-comment">// 标记不再添加元素</span><br>        &#125;);<br><br>        <span class="hljs-comment">// 启动消费者线程</span><br>        Thread consumerThread = new Thread(() =&gt;<br>        &#123;<br>            foreach (var item in blockingCollection.GetConsumingEnumerable())<br>            &#123;<br>                Console.WriteLine($<span class="hljs-string">&quot;Consumer consumed: &#123;item&#125;&quot;</span>);<br>                Thread.Sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟消费时间</span><br>            &#125;<br>        &#125;);<br><br>        producerThread.Start();<br>        consumerThread.Start();<br><br>        producerThread.Join();<br>        consumerThread.Join();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">Producer added: <span class="hljs-number">1</span><br>Producer added: <span class="hljs-number">2</span><br>Consumer consumed: <span class="hljs-number">1</span><br>Producer added: <span class="hljs-number">3</span><br>Consumer consumed: <span class="hljs-number">2</span><br>Producer added: <span class="hljs-number">4</span><br>Consumer consumed: <span class="hljs-number">3</span><br>Producer added: <span class="hljs-number">5</span><br>Consumer consumed: <span class="hljs-number">4</span><br>Producer added: <span class="hljs-number">6</span><br>Consumer consumed: <span class="hljs-number">5</span><br>Producer added: <span class="hljs-number">7</span><br>Consumer consumed: <span class="hljs-number">6</span><br>Producer added: <span class="hljs-number">8</span><br>Consumer consumed: <span class="hljs-number">7</span><br>Producer added: <span class="hljs-number">9</span><br>Consumer consumed: <span class="hljs-number">8</span><br>Producer added: <span class="hljs-number">10</span><br>Consumer consumed: <span class="hljs-number">9</span><br>Consumer consumed: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>线程安全：<code>BlockingCollection&lt;T&gt;</code> 是线程安全的，但需要确保对集合的操作不会与其他非线程安全的操作混用。</li><li>容量限制：如果集合满了，生产者线程会阻塞，因此需要合理设置容量。</li><li>异常处理：在生产者调用 <code>Add()</code> 或消费者调用 <code>Take()</code> 时，可能会抛出异常（如集合已满或已标记为完成添加）。建议使用 <code>TryAdd()</code> 和 <code>TryTake()</code> 方法来避免异常。<br><code>BlockingCollection&lt;T&gt;</code> 是 <code>C#</code> 中实现线程安全的生产者-消费者模式的利器，它简化了线程同步的复杂性，非常适合多线程编程场景。</li></ul><hr><h1 id="串口接收"><a href="#串口接收" class="headerlink" title="串口接收"></a>串口接收</h1><p>在使用 <code>BlockingCollection&lt;T&gt;</code> 存储串口接收的数据，并在其他线程中取出时，是否能<em><strong>保证数据的顺序</strong></em>，主要取决于以下两个因素：</p><h2 id="底层存储的类型"><a href="#底层存储的类型" class="headerlink" title="底层存储的类型"></a>底层存储的类型</h2><p><code>BlockingCollection&lt;T&gt;</code> 允许指定底层存储的类型。默认情况下，它使用 <code>ConcurrentQueue&lt;T&gt;</code> 作为底层存储，而 <code>ConcurrentQueue&lt;T&gt;</code> 是一个<em><strong>先进先出 FIFO</strong></em>的队列。这意味着数据的添加顺序和取出顺序是一致的，因此可以保证顺序。<br>如果你使用其他类型的底层存储（如 <code>ConcurrentStack&lt;T&gt;</code> 或自定义的线程安全集合），则顺序可能会有所不同。例如：<br><code>ConcurrentQueue&lt;T&gt;</code>：保证 <em><strong>FIFO</strong></em> 顺序。<br><code>ConcurrentStack&lt;T&gt;</code>：保证 <em><strong>LIFO</strong></em>（后进先出）顺序。</p><h2 id="线程安全和并发访问"><a href="#线程安全和并发访问" class="headerlink" title="线程安全和并发访问"></a>线程安全和并发访问</h2><p><code>BlockingCollection&lt;T&gt;</code> 是线程安全的，因此即使在多线程环境下，数据的添加和取出操作也是安全的。只要底层存储是 <em><strong>FIFO</strong></em> 的（如 <code>ConcurrentQueue&lt;T&gt;</code>），数据的顺序就能得到保证。</p><h2 id="串口数据接收的顺序性"><a href="#串口数据接收的顺序性" class="headerlink" title="串口数据接收的顺序性"></a>串口数据接收的顺序性</h2><p>串口通信本身是按字节顺序接收数据的，因此只要数据是逐字节接收并立即添加到 <code>BlockingCollection&lt;T&gt;</code> 中，数据的顺序就能得到保证。<br>示例代码<br>以下是一个示例，展示如何使用 <code>BlockingCollection&lt;T&gt;</code> 存储串口接收的数据，并在其他线程中按顺序取出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c">using System;<br>using System.Collections.Concurrent;<br>using System.IO.Ports;<br>using System.Threading;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerialPortExample</span></span><br><span class="hljs-class">&#123;</span><br>    private SerialPort _serialPort;<br>    private BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt; _dataQueue = new BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>    public <span class="hljs-title function_">SerialPortExample</span><span class="hljs-params">(<span class="hljs-built_in">string</span> portName)</span><br>    &#123;<br>        _serialPort = new SerialPort(portName)<br>        &#123;<br>            BaudRate = <span class="hljs-number">9600</span>,<br>            DataBits = <span class="hljs-number">8</span>,<br>            Parity = Parity.None,<br>            StopBits = StopBits.One,<br>            ReadTimeout = <span class="hljs-number">500</span><br>        &#125;;<br><br>        _serialPort.DataReceived += SerialPort_DataReceived;<br>    &#125;<br><br>    private <span class="hljs-type">void</span> <span class="hljs-title function_">SerialPort_DataReceived</span><span class="hljs-params">(object sender, SerialDataReceivedEventArgs e)</span><br>    &#123;<br>        try<br>        &#123;<br>            <span class="hljs-built_in">string</span> data = _serialPort.ReadLine(); <span class="hljs-comment">// 假设数据以换行符分隔</span><br>            _dataQueue.Add(data); <span class="hljs-comment">// 将数据添加到阻塞集合</span><br>            Console.WriteLine($<span class="hljs-string">&quot;Received and added: &#123;data&#125;&quot;</span>);<br>        &#125;<br>        catch (Exception ex)<br>        &#123;<br>            Console.WriteLine($<span class="hljs-string">&quot;Error in DataReceived: &#123;ex.Message&#125;&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    public <span class="hljs-type">void</span> <span class="hljs-title function_">Start</span><span class="hljs-params">()</span><br>    &#123;<br>        _serialPort.Open();<br>        Thread consumerThread = new Thread(ConsumeData);<br>        consumerThread.Start();<br>    &#125;<br><br>    private <span class="hljs-type">void</span> <span class="hljs-title function_">ConsumeData</span><span class="hljs-params">()</span><br>    &#123;<br>        foreach (var data in _dataQueue.GetConsumingEnumerable())<br>        &#123;<br>            Console.WriteLine($<span class="hljs-string">&quot;Consumed: &#123;data&#125;&quot;</span>);<br>            <span class="hljs-comment">// 处理数据</span><br>        &#125;<br>    &#125;<br><br>    public <span class="hljs-type">void</span> <span class="hljs-title function_">Stop</span><span class="hljs-params">()</span><br>    &#123;<br>        _dataQueue.CompleteAdding();<br>        _serialPort.Close();<br>    &#125;<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Main</span><span class="hljs-params">()</span><br>    &#123;<br>        SerialPortExample example = new SerialPortExample(<span class="hljs-string">&quot;COM3&quot;</span>);<br>        example.Start();<br><br>        Console.WriteLine(<span class="hljs-string">&quot;Press Enter to exit...&quot;</span>);<br>        Console.ReadLine();<br><br>        example.Stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>底层存储：使用 <code>ConcurrentQueue&lt;T&gt;</code>（默认）可以保证数据的 <em><strong>FIFO</strong></em> 顺序。</li><li>线程安全：<code>BlockingCollection&lt;T&gt;</code> 是线程安全的，因此在多线程环境下不会出现数据顺序混乱的问题。</li><li>串口数据接收：只要串口接收的数据是按顺序添加到 <code>BlockingCollection&lt;T&gt;</code> 中的，顺序就能得到保证。</li></ul><p>因此，只要使用默认的 <code>ConcurrentQueue&lt;T&gt;</code> 作为底层存储，并且正确处理串口数据的接收和添加，<code>BlockingCollection&lt;T&gt;</code> 是可以保证数据顺序的。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp ArrayPool</title>
    <link href="/2025/03/07/C-Sharp-ArrayPool/"/>
    <url>/2025/03/07/C-Sharp-ArrayPool/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><p>在<code>C#</code>中，<code>ArrayPool&lt;T&gt;</code> 是一个非常有用的工具类，主要用于高效地管理数组的分配和回收，以减少内存分配和垃圾回收的压力。它属于 <code>System.Buffers</code> 命名空间，是<code>.NET Core</code>和<code>.NET 5+</code>中引入的一个重要特性。</p><h1 id="ArrayPool-的作用"><a href="#ArrayPool-的作用" class="headerlink" title="ArrayPool&lt;T&gt; 的作用"></a><code>ArrayPool&lt;T&gt;</code> 的作用</h1><p><code>ArrayPool&lt;T&gt;</code> 提供了一个共享的数组池，允许开发者从池中租用数组，并在使用完毕后归还数组。这种方式可以避免频繁创建和销毁数组，从而减少内存碎片化和垃圾回收的开销。它特别适用于需要频繁处理大量临时数组的场景，例如高性能计算、网络通信、数据流处理等。</p><h1 id="ArrayPool-的使用方式"><a href="#ArrayPool-的使用方式" class="headerlink" title="ArrayPool&lt;T&gt; 的使用方式"></a><code>ArrayPool&lt;T&gt;</code> 的使用方式</h1><p><code>ArrayPool&lt;T&gt;</code> 提供了两种主要的使用方式：</p><h2 id="共享数组池"><a href="#共享数组池" class="headerlink" title="共享数组池"></a>共享数组池</h2><p><code>.NET</code> 提供了一个全局的共享数组池，可以通过 <code>ArrayPool&lt;T&gt;.Shared</code> 访问。这种方式简单易用，适用于大多数场景。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Buffers;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 从共享数组池中租用数组</span><br>        Span&lt;<span class="hljs-built_in">int</span>&gt; buffer = ArrayPool&lt;<span class="hljs-built_in">int</span>&gt;.Shared.Rent(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">// 使用数组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.Length; i++)<br>            &#123;<br>                buffer[i] = i * <span class="hljs-number">2</span>;<br>            &#125;<br><br>            Console.WriteLine(<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, buffer));<br>        &#125;<br>        <span class="hljs-keyword">finally</span><br>        &#123;<br>            <span class="hljs-comment">// 归还数组到池中</span><br>            ArrayPool&lt;<span class="hljs-built_in">int</span>&gt;.Shared.Return(buffer.ToArray());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义数组池"><a href="#自定义数组池" class="headerlink" title="自定义数组池"></a>自定义数组池</h2><p>如果需要更精细的控制，可以创建自己的 <code>ArrayPool&lt;T&gt;</code> 实例。例如，可以指定最大数组大小、最大数组数量等参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Buffers;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建自定义数组池</span><br>        <span class="hljs-keyword">var</span> pool = ArrayPool&lt;<span class="hljs-built_in">int</span>&gt;.Create(maxArrayLength: <span class="hljs-number">1024</span>, maxArraysPerBucket: <span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 从自定义数组池中租用数组</span><br>        Span&lt;<span class="hljs-built_in">int</span>&gt; buffer = pool.Rent(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">// 使用数组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.Length; i++)<br>            &#123;<br>                buffer[i] = i * <span class="hljs-number">2</span>;<br>            &#125;<br><br>            Console.WriteLine(<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, buffer));<br>        &#125;<br>        <span class="hljs-keyword">finally</span><br>        &#123;<br>            <span class="hljs-comment">// 归还数组到池中</span><br>            pool.Return(buffer.ToArray());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>数组大小：租用数组时，<code>ArrayPool&lt;T&gt;</code> 会根据请求的大小返回一个大于或等于请求大小的数组。因此，实际返回的数组可能比请求的更大。</li><li>归还数组：在使用完数组后，必须调用 <code>Return</code> 方法将数组归还到池中。否则，池中的资源会逐渐耗尽。</li><li>线程安全：<code>ArrayPool&lt;T&gt;</code> 是线程安全的，可以在多线程环境中使用。</li><li>性能优化：使用 <code>ArrayPool&lt;T&gt;</code> 可以显著减少垃圾回收的频率和时间，但需要合理管理数组的租用和归还，避免资源泄漏。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><code>ArrayPool&lt;T&gt;</code> 适用于以下场景：</p><ul><li>需要频繁创建和销毁数组的场景。</li><li>对性能要求较高的场景，例如高性能计算、网络数据处理等。</li><li>需要减少内存碎片化的场景。</li></ul><hr><p>总之，<code>ArrayPool&lt;T&gt;</code> 是一个非常强大的工具，可以帮助开发者优化内存使用和提升程序性能。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C Sharp is</title>
    <link href="/2025/03/05/C-Sharp-is/"/>
    <url>/2025/03/05/C-Sharp-is/</url>
    
    <content type="html"><![CDATA[<style>/* 仅对本页面的代码块生效 */.markdown-body figure.highlight .code pre code,.markdown-body .highlight pre code,.markdown-body pre code {  font-family: "JetBrains Mono";  font-size: 14px;  font-variant-ligatures: contextual;}</style><p>在<code>C#</code>中，<code>is</code> 关键字有多种用途，主要用于<em><strong>类型检查</strong></em>和<em><strong>模式匹配</strong></em>。以下是 <code>is</code> 关键字的主要用法：</p><h1 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h1><p><code>is</code> 关键字可以用来检查一个对象是否兼容于指定的类型，或者是否实现了指定的接口。如果检查结果为真，则返回 <code>true</code>。</p><ul><li>示例：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;obj 是一个字符串类型&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;obj 不是字符串类型&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>obj is string</code> 检查 <code>obj</code> <em><strong>是否可以被转换为</strong></em> <code>string</code> 类型。</p><h1 id="模式匹配（Pattern-Matching）"><a href="#模式匹配（Pattern-Matching）" class="headerlink" title="模式匹配（Pattern Matching）"></a>模式匹配（<code>Pattern Matching</code>）</h1><p>从<code>C# 7.0</code>开始，<code>is</code> 关键字支持模式匹配。模式匹配允许你在检查类型的同时，将对象的值赋给一个新变量，以便进一步使用。</p><ul><li>示例：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> str)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;obj 是一个字符串，内容为：<span class="hljs-subst">&#123;str.ToUpper()&#125;</span>&quot;</span>); <span class="hljs-comment">// 使用 str 变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>obj is string str</code> 不仅检查 obj 是否是 string 类型，还将 <code>obj</code> 的值赋给变量 <code>str</code>，方便后续使用。</p><h1 id="模式匹配的类型模式"><a href="#模式匹配的类型模式" class="headerlink" title="模式匹配的类型模式"></a>模式匹配的类型模式</h1><p><code>is</code> 关键字支持多种模式，包括类型模式、常量模式、逻辑模式等。</p><ul><li>类型模式：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;obj 是字符串类型&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>常量模式：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;obj 是 null&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>逻辑模式（<code>C# 9.0</code>及以上）：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> str &amp;&amp; str.Length &gt; <span class="hljs-number">5</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;obj 是一个长度大于5的字符串：<span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="与-as-的区别"><a href="#与-as-的区别" class="headerlink" title="与 as 的区别"></a>与 <code>as</code> 的区别</h1><p><code>is</code> 关键字主要用于类型检查，返回一个布尔值（<code>true</code> 或 <code>false</code>）。<br><code>as</code> 关键字用于类型转换，返回目标类型的对象，如果转换失败则返回 <code>null</code>。</p><ul><li>示例：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-comment">// 使用 is 检查类型</span><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;obj 是字符串类型&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用 as 进行类型转换</span><br><span class="hljs-built_in">string</span> str = obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;obj 转换为字符串后的内容是：<span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="性能注意事项"><a href="#性能注意事项" class="headerlink" title="性能注意事项"></a>性能注意事项</h1><p><code>is</code> 关键字在类型检查时会进行运行时类型检查，因此可能会有性能开销。<br>如果只需要类型转换而不需要检查类型，建议使用 <code>as</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>is</code> 关键字在<code>C#</code>中是一个非常强大的工具，不仅可以用于类型检查，还可以结合模式匹配实现更复杂的逻辑。根据你的需求选择合适的用法即可。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
